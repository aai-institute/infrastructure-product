{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Infrastructure Project","text":"<p>This documentation is work in progress.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>jobs<ul> <li>assembler<ul> <li>config</li> <li>renderers</li> </ul> </li> <li>cli</li> <li>execute</li> <li>image</li> <li>job</li> <li>runner<ul> <li>base</li> <li>docker</li> <li>kueue</li> <li>ray</li> </ul> </li> <li>submission_context</li> <li>types</li> <li>utils<ul> <li>helpers</li> <li>kubernetes</li> <li>kueue</li> <li>math</li> <li>processes</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/jobs/","title":"jobs","text":""},{"location":"reference/jobs/#jobs.ImageOptions","title":"ImageOptions  <code>dataclass</code>","text":"Source code in <code>src/jobs/job.py</code> <pre><code>@dataclass(frozen=True)\nclass ImageOptions:\n    name: str | None = None\n    \"\"\"Name of the image. If unspecified, inferred from the job.\"\"\"\n\n    tag: str = \"latest\"\n    spec: Path | None = None\n    dockerfile: Path | None = None\n    build_context: Path = Path.cwd()\n\n    @property\n    def build_mode(self) -&gt; BuildMode:\n        if self.spec is not None:\n            return BuildMode.YAML\n        elif self.dockerfile is not None:\n            return BuildMode.DOCKERFILE\n        else:\n            raise ValueError(\n                \"error building image: either YAML spec or Dockerfile must be set.\"\n            )\n\n    def _canonicalize(self, attr: str) -&gt; Path | None:\n        path = self.__getattribute__(attr)\n\n        if path is None:\n            return None\n\n        if not isinstance(path, (str, Path)):\n            raise TypeError(f\"Expected {attr!r} to be a str or Path, got: {type(path)}\")\n\n        if isinstance(path, str):\n            path = Path(path)\n\n        canonical_path = path.resolve()\n        object.__setattr__(self, attr, canonical_path)\n\n        return canonical_path\n\n    def __post_init__(self) -&gt; None:\n        def _is_yaml(path: AnyPath) -&gt; bool:\n            filename = os.path.basename(path)\n            return filename.endswith((\".yaml\", \".yml\"))\n\n        self._canonicalize(\"dockerfile\")\n        self._canonicalize(\"build_context\")\n        self._canonicalize(\"spec\")\n\n        if self.spec is None and self.dockerfile is None:\n            raise ValueError(\"Must specify either image spec or Dockerfile\")\n\n        if self.spec is not None and self.dockerfile is not None:\n            raise ValueError(\"Cannot specify both image spec and Dockerfile\")\n\n        if self.spec is not None and not _is_yaml(self.spec):\n            raise ValueError(f\"Container image spec is not a YAML file: {self.spec}\")\n\n        if not self.build_context.is_dir():\n            raise ValueError(f\"Build context must be a directory: {self.build_context}\")\n\n        if self.dockerfile is not None and not self.dockerfile.is_relative_to(\n            self.build_context\n        ):\n            raise ValueError(\n                f\"Dockerfile must be relative to build context {self.build_context}\"\n            )\n</code></pre>"},{"location":"reference/jobs/#jobs.ImageOptions.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = None\n</code></pre> <p>Name of the image. If unspecified, inferred from the job.</p>"},{"location":"reference/jobs/#jobs.Job","title":"Job","text":"<p>               Bases: <code>Generic[P, T]</code></p> Source code in <code>src/jobs/job.py</code> <pre><code>class Job(Generic[P, T]):\n    def __init__(\n        self,\n        func: Callable[P, T],\n        *,\n        options: JobOptions | None = None,\n        context: SubmissionContext | None = None,\n    ) -&gt; None:\n        functools.update_wrapper(self, func)\n        self._func = func\n        self.options = options\n        self.context = context or SubmissionContext()\n\n        if (module := inspect.getmodule(self._func)) is None:\n            raise ValueError(\"Cannot derive module for Job function.\")\n\n        self._name = self._func.__name__\n        self._file = os.path.relpath(str(module.__file__))\n\n        self.validate()\n\n    @property\n    def name(self) -&gt; str:\n        return self._name\n\n    @property\n    def file(self) -&gt; str:\n        return self._file\n\n    def __call__(self, *args: P.args, **kwargs: P.kwargs) -&gt; T:\n        return self._func(*args, **kwargs)\n\n    def _render_dockerfile(self) -&gt; str:\n        \"\"\"Render the job's Dockerfile from a YAML spec.\"\"\"\n\n        if not (self.options and self.options.image):\n            raise ValueError(\"Container image options must be specified\")\n\n        image_spec = self.options.image.spec\n        if not image_spec:\n            raise ValueError(\"Container image spec must be specified\")\n\n        if not image_spec.is_file():\n            raise FileNotFoundError(\n                f\"Container image spec file not found: {image_spec.is_file()}\"\n            )\n\n        image_cfg = config.load_config(image_spec)\n\n        renderers = [cls(image_cfg) for cls in RENDERERS if cls.accepts(image_cfg)]\n        dockerfile_content = \"\"\n        for r in renderers:\n            dockerfile_content += r.render() + \"\\n\"\n        return dockerfile_content\n\n    def validate(self) -&gt; None:\n        if self.options:\n            validate_labels(self.options.labels)\n\n    def build_image(\n        self,\n        push: bool = False,\n    ) -&gt; Image | None:\n        if not self.options or not self.options.image:\n            raise ValueError(\"Need image options to build image\")\n        opts = self.options.image\n\n        tag = f\"{opts.name or self.name}:{opts.tag}\"\n\n        logging.info(f\"Building container image: {tag!r}\")\n\n        build_cmd = [\"docker\", \"build\", \"-t\", tag]\n        build_cmd.extend([f\"--label={k}={v}\" for k, v in self.options.labels.items()])\n\n        exit_code: int = -1\n        if opts.build_mode == BuildMode.YAML:\n            yaml = self._render_dockerfile()\n            with io.StringIO(yaml) as dockerfile:\n                build_cmd.extend([\"-f-\", f\"{ opts.build_context.absolute() }\"])\n                exit_code, _, _, _ = run_command(\n                    shlex.join(build_cmd),\n                    stdin=dockerfile,\n                    verbose=True,\n                )\n        elif opts.build_mode == BuildMode.DOCKERFILE:\n            if opts.dockerfile is None:\n                raise ValueError(\"Dockerfile path must be specified\")\n            if not opts.dockerfile.is_file():\n                raise FileNotFoundError(\n                    f\"Specified Dockerfile not found: {opts.dockerfile.absolute()}\"\n                )\n            build_cmd.extend(\n                [\"-f\", f\"{ opts.dockerfile }\", f\"{ opts.build_context.absolute() }\"]\n            )\n            exit_code, _, _, _ = run_command(\n                shlex.join(build_cmd),\n                verbose=True,\n            )\n\n        if exit_code == 0:\n            if push:\n                logging.info(\"Pushing container image to remote registry\")\n                exit_code, _, _, _ = run_command(\n                    f\"docker push {tag}\",\n                    verbose=True,\n                )\n                if exit_code != 0:\n                    return None\n\n            return Image(tag)\n        else:\n            return None\n</code></pre>"},{"location":"reference/jobs/#jobs.JobOptions","title":"JobOptions  <code>dataclass</code>","text":"Source code in <code>src/jobs/job.py</code> <pre><code>@dataclass(frozen=True)\nclass JobOptions:\n    resources: ResourceOptions | None = None\n    \"\"\"Resource requests for this job in Kubernetes format (see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#resource-units-in-kubernetes)\"\"\"\n    image: ImageOptions | None = None\n    scheduling: SchedulingOptions | None = None\n    labels: dict[str, str] = field(default_factory=dict)\n</code></pre>"},{"location":"reference/jobs/#jobs.JobOptions.resources","title":"resources  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resources: ResourceOptions | None = None\n</code></pre> <p>Resource requests for this job in Kubernetes format (see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#resource-units-in-kubernetes)</p>"},{"location":"reference/jobs/#jobs.SchedulingOptions","title":"SchedulingOptions  <code>dataclass</code>","text":"Source code in <code>src/jobs/job.py</code> <pre><code>@dataclass(frozen=True)\nclass SchedulingOptions:\n    priority_class: str | None = None\n    \"\"\"Kueue priority class name\"\"\"\n\n    queue_name: str | None = None\n    \"\"\"Kueue local queue name\"\"\"\n</code></pre>"},{"location":"reference/jobs/#jobs.SchedulingOptions.priority_class","title":"priority_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority_class: str | None = None\n</code></pre> <p>Kueue priority class name</p>"},{"location":"reference/jobs/#jobs.SchedulingOptions.queue_name","title":"queue_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queue_name: str | None = None\n</code></pre> <p>Kueue local queue name</p>"},{"location":"reference/jobs/#modules","title":"Modules","text":""},{"location":"reference/jobs/#assembler","title":"assembler","text":""},{"location":"reference/jobs/#cli","title":"cli","text":""},{"location":"reference/jobs/#execute","title":"execute","text":""},{"location":"reference/jobs/#image","title":"image","text":""},{"location":"reference/jobs/#job","title":"job","text":""},{"location":"reference/jobs/#runner","title":"runner","text":""},{"location":"reference/jobs/#submission_context","title":"submission_context","text":""},{"location":"reference/jobs/#types","title":"types","text":""},{"location":"reference/jobs/#utils","title":"utils","text":""},{"location":"reference/jobs/cli/","title":"cli","text":""},{"location":"reference/jobs/cli/#jobs.cli.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>CLI entrypoint for job submission</p> Source code in <code>src/jobs/cli.py</code> <pre><code>def main():\n    \"\"\"CLI entrypoint for job submission\"\"\"\n\n    logging.basicConfig(level=logging.DEBUG)\n    logging.getLogger(\"urllib3.connectionpool\").setLevel(logging.INFO)\n\n    args = _make_argparser().parse_args()\n    job = discover_job(args)\n\n    submit_job(job, args)\n</code></pre>"},{"location":"reference/jobs/execute/","title":"execute","text":""},{"location":"reference/jobs/image/","title":"image","text":""},{"location":"reference/jobs/job/","title":"job","text":""},{"location":"reference/jobs/job/#jobs.job.SchedulingOptions","title":"SchedulingOptions  <code>dataclass</code>","text":"Source code in <code>src/jobs/job.py</code> <pre><code>@dataclass(frozen=True)\nclass SchedulingOptions:\n    priority_class: str | None = None\n    \"\"\"Kueue priority class name\"\"\"\n\n    queue_name: str | None = None\n    \"\"\"Kueue local queue name\"\"\"\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.SchedulingOptions.priority_class","title":"priority_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority_class: str | None = None\n</code></pre> <p>Kueue priority class name</p>"},{"location":"reference/jobs/job/#jobs.job.SchedulingOptions.queue_name","title":"queue_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queue_name: str | None = None\n</code></pre> <p>Kueue local queue name</p>"},{"location":"reference/jobs/job/#jobs.job.ImageOptions","title":"ImageOptions  <code>dataclass</code>","text":"Source code in <code>src/jobs/job.py</code> <pre><code>@dataclass(frozen=True)\nclass ImageOptions:\n    name: str | None = None\n    \"\"\"Name of the image. If unspecified, inferred from the job.\"\"\"\n\n    tag: str = \"latest\"\n    spec: Path | None = None\n    dockerfile: Path | None = None\n    build_context: Path = Path.cwd()\n\n    @property\n    def build_mode(self) -&gt; BuildMode:\n        if self.spec is not None:\n            return BuildMode.YAML\n        elif self.dockerfile is not None:\n            return BuildMode.DOCKERFILE\n        else:\n            raise ValueError(\n                \"error building image: either YAML spec or Dockerfile must be set.\"\n            )\n\n    def _canonicalize(self, attr: str) -&gt; Path | None:\n        path = self.__getattribute__(attr)\n\n        if path is None:\n            return None\n\n        if not isinstance(path, (str, Path)):\n            raise TypeError(f\"Expected {attr!r} to be a str or Path, got: {type(path)}\")\n\n        if isinstance(path, str):\n            path = Path(path)\n\n        canonical_path = path.resolve()\n        object.__setattr__(self, attr, canonical_path)\n\n        return canonical_path\n\n    def __post_init__(self) -&gt; None:\n        def _is_yaml(path: AnyPath) -&gt; bool:\n            filename = os.path.basename(path)\n            return filename.endswith((\".yaml\", \".yml\"))\n\n        self._canonicalize(\"dockerfile\")\n        self._canonicalize(\"build_context\")\n        self._canonicalize(\"spec\")\n\n        if self.spec is None and self.dockerfile is None:\n            raise ValueError(\"Must specify either image spec or Dockerfile\")\n\n        if self.spec is not None and self.dockerfile is not None:\n            raise ValueError(\"Cannot specify both image spec and Dockerfile\")\n\n        if self.spec is not None and not _is_yaml(self.spec):\n            raise ValueError(f\"Container image spec is not a YAML file: {self.spec}\")\n\n        if not self.build_context.is_dir():\n            raise ValueError(f\"Build context must be a directory: {self.build_context}\")\n\n        if self.dockerfile is not None and not self.dockerfile.is_relative_to(\n            self.build_context\n        ):\n            raise ValueError(\n                f\"Dockerfile must be relative to build context {self.build_context}\"\n            )\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.ImageOptions.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = None\n</code></pre> <p>Name of the image. If unspecified, inferred from the job.</p>"},{"location":"reference/jobs/job/#jobs.job.JobOptions","title":"JobOptions  <code>dataclass</code>","text":"Source code in <code>src/jobs/job.py</code> <pre><code>@dataclass(frozen=True)\nclass JobOptions:\n    resources: ResourceOptions | None = None\n    \"\"\"Resource requests for this job in Kubernetes format (see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#resource-units-in-kubernetes)\"\"\"\n    image: ImageOptions | None = None\n    scheduling: SchedulingOptions | None = None\n    labels: dict[str, str] = field(default_factory=dict)\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.JobOptions.resources","title":"resources  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resources: ResourceOptions | None = None\n</code></pre> <p>Resource requests for this job in Kubernetes format (see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#resource-units-in-kubernetes)</p>"},{"location":"reference/jobs/job/#jobs.job.Job","title":"Job","text":"<p>               Bases: <code>Generic[P, T]</code></p> Source code in <code>src/jobs/job.py</code> <pre><code>class Job(Generic[P, T]):\n    def __init__(\n        self,\n        func: Callable[P, T],\n        *,\n        options: JobOptions | None = None,\n        context: SubmissionContext | None = None,\n    ) -&gt; None:\n        functools.update_wrapper(self, func)\n        self._func = func\n        self.options = options\n        self.context = context or SubmissionContext()\n\n        if (module := inspect.getmodule(self._func)) is None:\n            raise ValueError(\"Cannot derive module for Job function.\")\n\n        self._name = self._func.__name__\n        self._file = os.path.relpath(str(module.__file__))\n\n        self.validate()\n\n    @property\n    def name(self) -&gt; str:\n        return self._name\n\n    @property\n    def file(self) -&gt; str:\n        return self._file\n\n    def __call__(self, *args: P.args, **kwargs: P.kwargs) -&gt; T:\n        return self._func(*args, **kwargs)\n\n    def _render_dockerfile(self) -&gt; str:\n        \"\"\"Render the job's Dockerfile from a YAML spec.\"\"\"\n\n        if not (self.options and self.options.image):\n            raise ValueError(\"Container image options must be specified\")\n\n        image_spec = self.options.image.spec\n        if not image_spec:\n            raise ValueError(\"Container image spec must be specified\")\n\n        if not image_spec.is_file():\n            raise FileNotFoundError(\n                f\"Container image spec file not found: {image_spec.is_file()}\"\n            )\n\n        image_cfg = config.load_config(image_spec)\n\n        renderers = [cls(image_cfg) for cls in RENDERERS if cls.accepts(image_cfg)]\n        dockerfile_content = \"\"\n        for r in renderers:\n            dockerfile_content += r.render() + \"\\n\"\n        return dockerfile_content\n\n    def validate(self) -&gt; None:\n        if self.options:\n            validate_labels(self.options.labels)\n\n    def build_image(\n        self,\n        push: bool = False,\n    ) -&gt; Image | None:\n        if not self.options or not self.options.image:\n            raise ValueError(\"Need image options to build image\")\n        opts = self.options.image\n\n        tag = f\"{opts.name or self.name}:{opts.tag}\"\n\n        logging.info(f\"Building container image: {tag!r}\")\n\n        build_cmd = [\"docker\", \"build\", \"-t\", tag]\n        build_cmd.extend([f\"--label={k}={v}\" for k, v in self.options.labels.items()])\n\n        exit_code: int = -1\n        if opts.build_mode == BuildMode.YAML:\n            yaml = self._render_dockerfile()\n            with io.StringIO(yaml) as dockerfile:\n                build_cmd.extend([\"-f-\", f\"{ opts.build_context.absolute() }\"])\n                exit_code, _, _, _ = run_command(\n                    shlex.join(build_cmd),\n                    stdin=dockerfile,\n                    verbose=True,\n                )\n        elif opts.build_mode == BuildMode.DOCKERFILE:\n            if opts.dockerfile is None:\n                raise ValueError(\"Dockerfile path must be specified\")\n            if not opts.dockerfile.is_file():\n                raise FileNotFoundError(\n                    f\"Specified Dockerfile not found: {opts.dockerfile.absolute()}\"\n                )\n            build_cmd.extend(\n                [\"-f\", f\"{ opts.dockerfile }\", f\"{ opts.build_context.absolute() }\"]\n            )\n            exit_code, _, _, _ = run_command(\n                shlex.join(build_cmd),\n                verbose=True,\n            )\n\n        if exit_code == 0:\n            if push:\n                logging.info(\"Pushing container image to remote registry\")\n                exit_code, _, _, _ = run_command(\n                    f\"docker push {tag}\",\n                    verbose=True,\n                )\n                if exit_code != 0:\n                    return None\n\n            return Image(tag)\n        else:\n            return None\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.validate_labels","title":"validate_labels","text":"<pre><code>validate_labels(labels: dict[str, str]) -&gt; None\n</code></pre> <p>Validate the syntactic correctness of user-specified job labels.</p> <p>Note that the rules for labels are the intersection (i.e., the strictest subset) of syntax restrictions on Docker labels and Kubernetes annotations, so that the labels can be applied in either context.</p> <p>See the following documents for further reference: - Docker: https://docs.docker.com/config/labels-custom-metadata/#value-guidelines - Kubernetes: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set</p> RAISES DESCRIPTION <code>ValueError</code> <p>if the labels are not well-formed</p> Source code in <code>src/jobs/job.py</code> <pre><code>def validate_labels(labels: dict[str, str]) -&gt; None:\n    \"\"\"Validate the syntactic correctness of user-specified job labels.\n\n    Note that the rules for labels are the intersection (i.e., the strictest subset)\n    of syntax restrictions on Docker labels and Kubernetes annotations, so that the\n    labels can be applied in either context.\n\n    See the following documents for further reference:\n    - Docker: &lt;https://docs.docker.com/config/labels-custom-metadata/#value-guidelines&gt;\n    - Kubernetes: &lt;https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set&gt;\n\n    Raises\n    ------\n    ValueError\n        if the labels are not well-formed\n    \"\"\"\n    for k, v in labels.items():\n        # Label keys:\n        # - Must start and end with a letter\n        # - Can contain dashes (-), underscores (_), dots (.), slashes (/), and alphanumerics between.\n        # - May not contain prefixes (as used in Kubernetes), since they are not compatible with Docker\n        if not re.match(r\"^[a-z]+(?:[/._-][a-z0-9]+)*[a-z]?$\", k):\n            raise ValueError(f\"Label key is not well-formed: {k}\")\n\n        # Label values:\n        # - Maximum length of 127 characters\n        if len(v) &gt; 127:\n            raise ValueError(f\"Label value is not well-formed: {v}\")\n</code></pre>"},{"location":"reference/jobs/submission_context/","title":"submission_context","text":""},{"location":"reference/jobs/types/","title":"types","text":""},{"location":"reference/jobs/assembler/","title":"assembler","text":""},{"location":"reference/jobs/assembler/config/","title":"config","text":""},{"location":"reference/jobs/assembler/renderers/","title":"renderers","text":""},{"location":"reference/jobs/runner/","title":"runner","text":""},{"location":"reference/jobs/runner/#jobs.runner.RayClusterRunner","title":"RayClusterRunner","text":"<p>               Bases: <code>Runner</code></p> Source code in <code>src/jobs/runner/ray.py</code> <pre><code>class RayClusterRunner(Runner):\n    def __init__(self, **kwargs):\n        super().__init__()\n\n        self._head_url = kwargs.get(\"head_url\")\n        if self._head_url is None:\n            raise ValueError(\"Ray cluster head URL is unset\")\n\n    @staticmethod\n    def _wait_until_status(\n        job_id: str,\n        job_client: JobSubmissionClient,\n        status_to_wait_for: AbstractSet[JobStatus] = frozenset(\n            {JobStatus.SUCCEEDED, JobStatus.STOPPED, JobStatus.FAILED}\n        ),\n        timeout_seconds: int = 10,\n    ) -&gt; tuple[float, JobStatus]:\n        \"\"\"Wait until a Ray Job has entered any of a set of desired states (defaults to all final states).\"\"\"\n\n        start = time.time()\n        status = job_client.get_job_status(job_id)\n\n        # 0 means no timeout\n        if timeout_seconds == 0:\n            timeout_seconds = sys.maxsize\n\n        while time.time() - start &lt;= timeout_seconds:\n            if status in status_to_wait_for:\n                break\n            time.sleep(0.5)\n            status = job_client.get_job_status(job_id)\n\n        return time.time() - start, status\n\n    def run(self, job: Job, image: Image) -&gt; None:\n        head_url = self._head_url\n        logging.info(f\"Submitting job {job.name} to Ray cluster at {head_url!r}\")\n\n        ray_jobs = JobSubmissionClient(head_url)\n        ray_options: RayResourceOptions | NoOptions = (\n            res.to_ray()\n            if job.options and (res := job.options.resources)\n            else NoOptions()\n        )\n\n        # TODO: Lots of hardcoded stuff here\n        suffix = \"\".join(random.choices(string.ascii_lowercase + string.digits, k=4))\n        job_id = ray_jobs.submit_job(\n            submission_id=f\"{job.name}_{suffix}\",\n            entrypoint=shlex.join(_make_executor_command(job)),\n            runtime_env={\n                \"working_dir\": Path(job.file).parent,\n                \"pip\": Path(\"requirements.txt\").read_text(\"utf-8\").splitlines(),\n                \"py_modules\": [jobs],\n            },\n            **ray_options,\n        )\n        logging.info(f\"Submitted Ray job with ID {job_id}\")\n\n        execution_time, status = self._wait_until_status(\n            job_id, ray_jobs, timeout_seconds=0\n        )\n        logging.info(\n            f\"Job finished with status {status.value!r} in {execution_time:.1f}s\"\n        )\n</code></pre>"},{"location":"reference/jobs/runner/#jobs.runner.RayJobRunner","title":"RayJobRunner","text":"<p>               Bases: <code>Runner</code>, <code>KubernetesNamespaceMixin</code></p> <p>Job runner that submits <code>RayJob</code> resources to a Kubernetes cluster running the Kuberay operator.</p> Source code in <code>src/jobs/runner/ray.py</code> <pre><code>class RayJobRunner(Runner, KubernetesNamespaceMixin):\n    \"\"\"Job runner that submits ``RayJob`` resources to a Kubernetes cluster running the Kuberay operator.\"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n    def _create_ray_job(self, job: Job, image: Image) -&gt; dict:\n        \"\"\"Create a ``RayJob`` Kubernetes resource for the Kuberay operator.\"\"\"\n\n        if job.options is None:\n            raise ValueError(\"Job options must be set\")\n\n        res_opts = job.options.resources\n        if not res_opts:\n            raise ValueError(\"Job resource options must be set\")\n\n        try:\n            ray_version = importlib.metadata.version(\"ray\")\n        except importlib.metadata.PackageNotFoundError:\n            raise RuntimeError(\n                \"Could not determine Ray version, is it installed in your environment?\"\n            )\n\n        scheduling_labels = kueue_scheduling_labels(job, self.namespace)\n\n        runtime_env = {\n            \"working_dir\": \"/home/ray/app\",\n        }\n\n        suffix = \"\".join(random.choices(string.ascii_lowercase + string.digits, k=4))\n        job_id = f\"{job.name}-{suffix}\"\n        manifest = {\n            \"apiVersion\": \"ray.io/v1\",\n            \"kind\": \"RayJob\",\n            \"metadata\": {\n                \"name\": sanitize_rfc1123_domain_name(job_id),\n                \"labels\": scheduling_labels,\n                \"annotations\": k8s_annotations(job),\n            },\n            \"spec\": {\n                \"jobId\": job_id,\n                \"entrypoint\": shlex.join(_make_executor_command(job)),\n                \"runtimeEnvYAML\": yaml.dump(runtime_env),\n                \"shutdownAfterJobFinishes\": True,\n                \"rayClusterSpec\": {\n                    \"rayVersion\": ray_version,\n                    \"headGroupSpec\": {\n                        \"rayStartParams\": {\n                            \"dashboard-host\": \"0.0.0.0\",\n                            \"disable-usage-stats\": \"true\",\n                        },\n                        \"template\": {\n                            \"spec\": {\n                                \"containers\": [\n                                    {\n                                        \"name\": \"head\",\n                                        \"image\": image.tag,\n                                        \"imagePullPolicy\": \"Always\",\n                                        \"resources\": {\n                                            \"requests\": res_opts.to_kubernetes(\n                                                kind=K8sResourceKind.REQUESTS\n                                            ),\n                                            \"limits\": res_opts.to_kubernetes(\n                                                kind=K8sResourceKind.LIMITS\n                                            ),\n                                        },\n                                    },\n                                ]\n                            }\n                        },\n                    },\n                },\n            },\n        }\n\n        return manifest\n\n    def run(self, job: Job, image: Image) -&gt; None:\n        logging.info(f\"Submitting RayJob {job.name} to namespace {self.namespace!r}\")\n\n        manifest = self._create_ray_job(job, image)\n        api = client.CustomObjectsApi()\n        res = api.create_namespaced_custom_object(\n            \"ray.io\", \"v1\", self.namespace, \"rayjobs\", manifest\n        )\n</code></pre>"},{"location":"reference/jobs/runner/base/","title":"base","text":""},{"location":"reference/jobs/runner/docker/","title":"docker","text":""},{"location":"reference/jobs/runner/kueue/","title":"kueue","text":""},{"location":"reference/jobs/runner/ray/","title":"ray","text":""},{"location":"reference/jobs/runner/ray/#jobs.runner.ray.RayClusterRunner","title":"RayClusterRunner","text":"<p>               Bases: <code>Runner</code></p> Source code in <code>src/jobs/runner/ray.py</code> <pre><code>class RayClusterRunner(Runner):\n    def __init__(self, **kwargs):\n        super().__init__()\n\n        self._head_url = kwargs.get(\"head_url\")\n        if self._head_url is None:\n            raise ValueError(\"Ray cluster head URL is unset\")\n\n    @staticmethod\n    def _wait_until_status(\n        job_id: str,\n        job_client: JobSubmissionClient,\n        status_to_wait_for: AbstractSet[JobStatus] = frozenset(\n            {JobStatus.SUCCEEDED, JobStatus.STOPPED, JobStatus.FAILED}\n        ),\n        timeout_seconds: int = 10,\n    ) -&gt; tuple[float, JobStatus]:\n        \"\"\"Wait until a Ray Job has entered any of a set of desired states (defaults to all final states).\"\"\"\n\n        start = time.time()\n        status = job_client.get_job_status(job_id)\n\n        # 0 means no timeout\n        if timeout_seconds == 0:\n            timeout_seconds = sys.maxsize\n\n        while time.time() - start &lt;= timeout_seconds:\n            if status in status_to_wait_for:\n                break\n            time.sleep(0.5)\n            status = job_client.get_job_status(job_id)\n\n        return time.time() - start, status\n\n    def run(self, job: Job, image: Image) -&gt; None:\n        head_url = self._head_url\n        logging.info(f\"Submitting job {job.name} to Ray cluster at {head_url!r}\")\n\n        ray_jobs = JobSubmissionClient(head_url)\n        ray_options: RayResourceOptions | NoOptions = (\n            res.to_ray()\n            if job.options and (res := job.options.resources)\n            else NoOptions()\n        )\n\n        # TODO: Lots of hardcoded stuff here\n        suffix = \"\".join(random.choices(string.ascii_lowercase + string.digits, k=4))\n        job_id = ray_jobs.submit_job(\n            submission_id=f\"{job.name}_{suffix}\",\n            entrypoint=shlex.join(_make_executor_command(job)),\n            runtime_env={\n                \"working_dir\": Path(job.file).parent,\n                \"pip\": Path(\"requirements.txt\").read_text(\"utf-8\").splitlines(),\n                \"py_modules\": [jobs],\n            },\n            **ray_options,\n        )\n        logging.info(f\"Submitted Ray job with ID {job_id}\")\n\n        execution_time, status = self._wait_until_status(\n            job_id, ray_jobs, timeout_seconds=0\n        )\n        logging.info(\n            f\"Job finished with status {status.value!r} in {execution_time:.1f}s\"\n        )\n</code></pre>"},{"location":"reference/jobs/runner/ray/#jobs.runner.ray.RayJobRunner","title":"RayJobRunner","text":"<p>               Bases: <code>Runner</code>, <code>KubernetesNamespaceMixin</code></p> <p>Job runner that submits <code>RayJob</code> resources to a Kubernetes cluster running the Kuberay operator.</p> Source code in <code>src/jobs/runner/ray.py</code> <pre><code>class RayJobRunner(Runner, KubernetesNamespaceMixin):\n    \"\"\"Job runner that submits ``RayJob`` resources to a Kubernetes cluster running the Kuberay operator.\"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n    def _create_ray_job(self, job: Job, image: Image) -&gt; dict:\n        \"\"\"Create a ``RayJob`` Kubernetes resource for the Kuberay operator.\"\"\"\n\n        if job.options is None:\n            raise ValueError(\"Job options must be set\")\n\n        res_opts = job.options.resources\n        if not res_opts:\n            raise ValueError(\"Job resource options must be set\")\n\n        try:\n            ray_version = importlib.metadata.version(\"ray\")\n        except importlib.metadata.PackageNotFoundError:\n            raise RuntimeError(\n                \"Could not determine Ray version, is it installed in your environment?\"\n            )\n\n        scheduling_labels = kueue_scheduling_labels(job, self.namespace)\n\n        runtime_env = {\n            \"working_dir\": \"/home/ray/app\",\n        }\n\n        suffix = \"\".join(random.choices(string.ascii_lowercase + string.digits, k=4))\n        job_id = f\"{job.name}-{suffix}\"\n        manifest = {\n            \"apiVersion\": \"ray.io/v1\",\n            \"kind\": \"RayJob\",\n            \"metadata\": {\n                \"name\": sanitize_rfc1123_domain_name(job_id),\n                \"labels\": scheduling_labels,\n                \"annotations\": k8s_annotations(job),\n            },\n            \"spec\": {\n                \"jobId\": job_id,\n                \"entrypoint\": shlex.join(_make_executor_command(job)),\n                \"runtimeEnvYAML\": yaml.dump(runtime_env),\n                \"shutdownAfterJobFinishes\": True,\n                \"rayClusterSpec\": {\n                    \"rayVersion\": ray_version,\n                    \"headGroupSpec\": {\n                        \"rayStartParams\": {\n                            \"dashboard-host\": \"0.0.0.0\",\n                            \"disable-usage-stats\": \"true\",\n                        },\n                        \"template\": {\n                            \"spec\": {\n                                \"containers\": [\n                                    {\n                                        \"name\": \"head\",\n                                        \"image\": image.tag,\n                                        \"imagePullPolicy\": \"Always\",\n                                        \"resources\": {\n                                            \"requests\": res_opts.to_kubernetes(\n                                                kind=K8sResourceKind.REQUESTS\n                                            ),\n                                            \"limits\": res_opts.to_kubernetes(\n                                                kind=K8sResourceKind.LIMITS\n                                            ),\n                                        },\n                                    },\n                                ]\n                            }\n                        },\n                    },\n                },\n            },\n        }\n\n        return manifest\n\n    def run(self, job: Job, image: Image) -&gt; None:\n        logging.info(f\"Submitting RayJob {job.name} to namespace {self.namespace!r}\")\n\n        manifest = self._create_ray_job(job, image)\n        api = client.CustomObjectsApi()\n        res = api.create_namespaced_custom_object(\n            \"ray.io\", \"v1\", self.namespace, \"rayjobs\", manifest\n        )\n</code></pre>"},{"location":"reference/jobs/utils/","title":"utils","text":""},{"location":"reference/jobs/utils/helpers/","title":"helpers","text":""},{"location":"reference/jobs/utils/helpers/#jobs.utils.helpers.remove_none_values","title":"remove_none_values","text":"<pre><code>remove_none_values(d: T) -&gt; T\n</code></pre> <p>Remove all keys with a <code>None</code> value from a dict.</p> Source code in <code>src/jobs/utils/helpers.py</code> <pre><code>def remove_none_values(d: T) -&gt; T:\n    \"\"\"Remove all keys with a ``None`` value from a dict.\"\"\"\n    filtered_dict = {k: v for k, v in d.items() if v is not None}\n    return cast(T, filtered_dict)\n</code></pre>"},{"location":"reference/jobs/utils/kubernetes/","title":"kubernetes","text":""},{"location":"reference/jobs/utils/kubernetes/#jobs.utils.kubernetes.KubernetesNamespaceMixin","title":"KubernetesNamespaceMixin","text":"<p>Determine the desired or current Kubernetes namespace.</p> Source code in <code>src/jobs/utils/kubernetes.py</code> <pre><code>class KubernetesNamespaceMixin:\n    \"\"\"Determine the desired or current Kubernetes namespace.\"\"\"\n\n    def __init__(self, **kwargs):\n        kubernetes.config.load_config()\n        self._namespace: str | None = kwargs.get(\"namespace\")\n\n    @property\n    def namespace(self) -&gt; str:\n        _, active_context = kubernetes.config.list_kube_config_contexts()\n        current_namespace = active_context[\"context\"].get(\"namespace\")\n        return self._namespace or current_namespace\n</code></pre>"},{"location":"reference/jobs/utils/kubernetes/#jobs.utils.kubernetes.sanitize_rfc1123_domain_name","title":"sanitize_rfc1123_domain_name","text":"<pre><code>sanitize_rfc1123_domain_name(s: str) -&gt; str\n</code></pre> <p>Sanitize a string to be compliant with RFC 1123 domain name</p> <p>Note: Any invalid characters are replaced with dashes.</p> Source code in <code>src/jobs/utils/kubernetes.py</code> <pre><code>def sanitize_rfc1123_domain_name(s: str) -&gt; str:\n    \"\"\"Sanitize a string to be compliant with RFC 1123 domain name\n\n    Note: Any invalid characters are replaced with dashes.\"\"\"\n\n    # TODO: This is obviously wildly incomplete\n    return s.replace(\"_\", \"-\")\n</code></pre>"},{"location":"reference/jobs/utils/kubernetes/#jobs.utils.kubernetes.k8s_annotations","title":"k8s_annotations","text":"<pre><code>k8s_annotations(job: Job) -&gt; dict[str, str]\n</code></pre> <p>Determine the Kubernetes annotations for a Job</p> Source code in <code>src/jobs/utils/kubernetes.py</code> <pre><code>def k8s_annotations(job: Job) -&gt; dict[str, str]:\n    \"\"\"Determine the Kubernetes annotations for a Job\"\"\"\n    # Store as annotations since labels have restrictive value formats\n    options = job.options.labels if job.options else {}\n    context = job.context.resolve() if job.context else {}\n    return options | context\n</code></pre>"},{"location":"reference/jobs/utils/kueue/","title":"kueue","text":""},{"location":"reference/jobs/utils/kueue/#jobs.utils.kueue.assert_kueue_localqueue","title":"assert_kueue_localqueue","text":"<pre><code>assert_kueue_localqueue(namespace: str, name: str) -&gt; bool\n</code></pre> <p>Check the existence of a Kueue <code>LocalQueue</code> in a namespace.</p> Source code in <code>src/jobs/utils/kueue.py</code> <pre><code>def assert_kueue_localqueue(namespace: str, name: str) -&gt; bool:\n    \"\"\"Check the existence of a Kueue `LocalQueue` in a namespace.\"\"\"\n    try:\n        _ = client.CustomObjectsApi().get_namespaced_custom_object(\n            \"kueue.x-k8s.io\",\n            \"v1beta1\",\n            namespace,\n            \"localqueues\",\n            name,\n        )\n        return True\n    except client.exceptions.ApiException:\n        return False\n</code></pre>"},{"location":"reference/jobs/utils/kueue/#jobs.utils.kueue.assert_kueue_workloadpriorityclass","title":"assert_kueue_workloadpriorityclass","text":"<pre><code>assert_kueue_workloadpriorityclass(name: str) -&gt; bool\n</code></pre> <p>Check the existence of a Kueue <code>WorkloadPriorityClass</code> in the cluster.</p> Source code in <code>src/jobs/utils/kueue.py</code> <pre><code>def assert_kueue_workloadpriorityclass(name: str) -&gt; bool:\n    \"\"\"Check the existence of a Kueue `WorkloadPriorityClass` in the cluster.\"\"\"\n    try:\n        _ = client.CustomObjectsApi().get_cluster_custom_object(\n            \"kueue.x-k8s.io\",\n            \"v1beta1\",\n            \"workloadpriorityclasses\",\n            name,\n        )\n        return True\n    except client.exceptions.ApiException:\n        return False\n</code></pre>"},{"location":"reference/jobs/utils/kueue/#jobs.utils.kueue.kueue_scheduling_labels","title":"kueue_scheduling_labels","text":"<pre><code>kueue_scheduling_labels(job: Job, namespace: str) -&gt; Mapping[str, str]\n</code></pre> <p>Determine the Kubernetes labels controlling Kueue features such as queues and priority for a job.</p> Source code in <code>src/jobs/utils/kueue.py</code> <pre><code>def kueue_scheduling_labels(job: Job, namespace: str) -&gt; Mapping[str, str]:\n    \"\"\"Determine the Kubernetes labels controlling Kueue features such as queues and priority for a job.\"\"\"\n\n    if not job.options:\n        return {}\n    if not (sched_opts := job.options.scheduling):\n        return {}\n\n    if queue := sched_opts.queue_name:\n        if not assert_kueue_localqueue(namespace, queue):\n            raise ValueError(f\"Specified Kueue local queue does not exist: {queue!r}\")\n    if pc := sched_opts.priority_class:\n        if not assert_kueue_workloadpriorityclass(pc):\n            raise ValueError(\n                f\"Specified Kueue workload priority class does not exist: {pc!r}\"\n            )\n\n    return cast(\n        Mapping[str, str],\n        remove_none_values(\n            {\n                \"kueue.x-k8s.io/queue-name\": (\n                    sched_opts.queue_name if sched_opts else None\n                ),\n                \"kueue.x-k8s.io/priority-class\": (\n                    sched_opts.priority_class if sched_opts else None\n                ),\n            }\n        ),\n    )\n</code></pre>"},{"location":"reference/jobs/utils/math/","title":"math","text":""},{"location":"reference/jobs/utils/math/#jobs.utils.math.to_rational","title":"to_rational","text":"<pre><code>to_rational(s: str) -&gt; float\n</code></pre> <p>Convert a number with optional SI/binary unit to floating-point</p> Source code in <code>src/jobs/utils/math.py</code> <pre><code>def to_rational(s: str) -&gt; float:\n    \"\"\"Convert a number with optional SI/binary unit to floating-point\"\"\"\n\n    matches = re.match(r\"(?P&lt;magnitude&gt;[+\\-]?\\d*[.,]?\\d+)(?P&lt;suffix&gt;[a-zA-Z]*)\", s)\n    if not matches:\n        raise ValueError(f\"Could not parse {s}\")\n    magnitude = float(matches.group(\"magnitude\"))\n    suffix = matches.group(\"suffix\")\n\n    factor = {\n        # SI / Metric\n        \"m\": 1e-3,\n        \"k\": 1e3,\n        \"M\": 1e6,\n        \"G\": 1e9,\n        \"T\": 1e12,\n        # Binary\n        \"Ki\": 2**10,\n        \"Mi\": 2**20,\n        \"Gi\": 2**30,\n        \"Ti\": 2**40,\n        # default\n        \"\": 1.0,\n    }.get(suffix)\n    if factor is None:\n        raise ValueError(f\"unknown unit suffix: {suffix}\")\n\n    return factor * magnitude\n</code></pre>"},{"location":"reference/jobs/utils/processes/","title":"processes","text":""},{"location":"reference/jobs/utils/processes/#jobs.utils.processes.run_command","title":"run_command","text":"<pre><code>run_command(\n    command: str,\n    cwd: AnyPath | None = None,\n    verbose: bool = False,\n    env: Mapping[str, str] | None = None,\n    stdin: TextIO | None = None,\n) -&gt; tuple[int, list[str], list[str], list[str]]\n</code></pre> <p>Run a command in a subprocess.</p> PARAMETER DESCRIPTION <code>command</code> <p>Command to run</p> <p> TYPE: <code>str</code> </p> <code>cwd</code> <p>Working directory</p> <p> TYPE: <code>PathLike[str] | Path | None</code> DEFAULT: <code>None</code> </p> <code>verbose</code> <p>Forward command output to stdout/stderr</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>env</code> <p>Environment for the new process, by default the current environment</p> <p> TYPE: <code>dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>stdin</code> <p>Standard input for the new process, by default <code>None</code></p> <p> TYPE: <code>BinaryIO | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>tuple[int, list[str], list[str], list[str]]</code> <p>a tuple containing the return code and the output of the command (stdout, stderr, and combined)</p> Source code in <code>src/jobs/utils/processes.py</code> <pre><code>def run_command(\n    command: str,\n    cwd: AnyPath | None = None,\n    verbose: bool = False,\n    env: Mapping[str, str] | None = None,\n    stdin: TextIO | None = None,\n) -&gt; tuple[int, list[str], list[str], list[str]]:\n    \"\"\"Run a command in a subprocess.\n\n    Parameters\n    ----------\n    command : str\n        Command to run\n    cwd : os.PathLike[str] | Path | None, optional\n        Working directory\n    verbose : bool, optional\n        Forward command output to stdout/stderr\n    env : dict[str, str], optional\n        Environment for the new process, by default the current environment\n    stdin : BinaryIO | None, optional\n        Standard input for the new process, by default `None`\n\n    Returns\n    -------\n    tuple[int, list[str], list[str], list[str]]\n        a tuple containing the return code and the output of the command (stdout, stderr, and combined)\n    \"\"\"\n\n    logging.debug(\"Running command: %s\", command)\n    # No need to split the command string on Windows\n    if sys.platform == \"win32\":\n        args = command\n    else:\n        args = shlex.split(command)\n\n    process = subprocess.Popen(\n        args=args,\n        stdin=subprocess.PIPE if stdin else None,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        cwd=cwd,\n        env=env,\n        encoding=\"utf-8\",\n    )\n\n    if stdin is not None and process.stdin:\n        process.stdin.write(stdin.read())\n        process.stdin.close()\n\n    # Capture stdout and stderr\n    stdout: list[str] = []\n    stderr: list[str] = []\n    output: list[str] = []\n\n    def _reader(\n        in_stream: TextIO | None,\n        out_stream: TextIOBase,\n        out_lists: Iterable[list[str]],\n    ) -&gt; None:\n        if in_stream is None:\n            return\n        for line in in_stream:\n            for out in out_lists:\n                out.append(line)\n\n            if verbose:\n                out_stream.write(line)\n                out_stream.flush()\n\n    read_stdout = threading.Thread(\n        target=_reader,\n        kwargs={\n            \"in_stream\": process.stdout,\n            \"out_stream\": sys.stdout,\n            \"out_lists\": [stdout, output],\n        },\n    )\n    read_stderr = threading.Thread(\n        target=_reader,\n        kwargs={\n            \"in_stream\": process.stderr,\n            \"out_stream\": sys.stderr,\n            \"out_lists\": [stderr, output],\n        },\n    )\n\n    read_stdout.start()\n    read_stderr.start()\n\n    # Wait for process to finish\n    while process.poll() is None:\n        time.sleep(0.1)\n\n    read_stdout.join()\n    read_stderr.join()\n\n    return process.returncode, stdout, stderr, output\n</code></pre>"}]}