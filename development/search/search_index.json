{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Infrastructure Project","text":"<p>This documentation is work in progress.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>jobs<ul> <li>assembler<ul> <li>config</li> <li>renderers</li> </ul> </li> <li>cli</li> <li>execute</li> <li>image</li> <li>job</li> <li>submission_context</li> <li>types</li> <li>utils<ul> <li>helpers</li> <li>math</li> <li>processes</li> </ul> </li> </ul> </li> <li>openapi_client<ul> <li>api<ul> <li>job_management_api</li> </ul> </li> <li>api_client</li> <li>api_response</li> <li>configuration</li> <li>exceptions</li> <li>models<ul> <li>create_job_model</li> <li>execution_mode</li> <li>http_validation_error</li> <li>job_options</li> <li>resource_options</li> <li>scheduling_options</li> <li>validation_error</li> <li>validation_error_loc_inner</li> <li>workload_identifier</li> </ul> </li> <li>rest</li> <li>test<ul> <li>test_create_job_model</li> <li>test_execution_mode</li> <li>test_http_validation_error</li> <li>test_job_management_api</li> <li>test_job_options</li> <li>test_resource_options</li> <li>test_scheduling_options</li> <li>test_validation_error</li> <li>test_validation_error_loc_inner</li> <li>test_workload_identifier</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/jobs/","title":"jobs","text":""},{"location":"reference/jobs/#jobs.ImageOptions","title":"ImageOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>ImageOptions</p> Source code in <code>src/jobs/job.py</code> <pre><code>class ImageOptions(BaseModel):\n    \"\"\"\n    ImageOptions\n    \"\"\"  # noqa: E501\n\n    name: StrictStr | None = None\n    tag: StrictStr | None = \"latest\"\n    spec: Path | None = None\n    dockerfile: Path | None = None\n    build_context: Path = (\n        Path.cwd()\n    )  # FIXME: Maybe don't have a default here but rather only set it at build time\n    __properties: ClassVar[list[str]] = [\n        \"name\",\n        \"tag\",\n        \"spec\",\n        \"dockerfile\",\n        \"build_context\",\n    ]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of ImageOptions from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: AbstractSet[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # set to None if name (nullable) is None\n        # and model_fields_set contains the field\n        if self.name is None and \"name\" in self.model_fields_set:\n            _dict[\"name\"] = None\n\n        # set to None if spec (nullable) is None\n        # and model_fields_set contains the field\n        if self.spec is None and \"spec\" in self.model_fields_set:\n            _dict[\"spec\"] = None\n\n        # set to None if dockerfile (nullable) is None\n        # and model_fields_set contains the field\n        if self.dockerfile is None and \"dockerfile\" in self.model_fields_set:\n            _dict[\"dockerfile\"] = None\n\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of ImageOptions from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"name\": obj.get(\"name\"),\n            \"tag\": obj.get(\"tag\") if obj.get(\"tag\") is not None else \"latest\",\n            \"spec\": obj.get(\"spec\"),\n            \"dockerfile\": obj.get(\"dockerfile\"),\n            \"build_context\": obj.get(\"build_context\")\n            if obj.get(\"build_context\") is not None\n            else \"/Users/adriano/work/docker-job-poc/backend\",\n        })\n        return _obj\n\n    @property\n    def build_mode(self) -&gt; BuildMode:\n        if self.spec is not None:\n            return BuildMode.YAML\n        elif self.dockerfile is not None:\n            return BuildMode.DOCKERFILE\n        else:\n            raise ValueError(\n                \"error building image: either YAML spec or Dockerfile must be set.\"\n            )\n\n    def _canonicalize(self, attr: str) -&gt; Path | None:\n        path = self.__getattribute__(attr)\n\n        if path is None:\n            return None\n\n        if not isinstance(path, str | Path):\n            raise TypeError(f\"Expected {attr!r} to be a str or Path, got: {type(path)}\")\n\n        if isinstance(path, str):\n            path = Path(path)\n\n        canonical_path = path.resolve()\n        object.__setattr__(self, attr, canonical_path)\n\n        return canonical_path\n\n    def model_post_init(self, /, __context: Any) -&gt; None:\n        def _is_yaml(path: AnyPath) -&gt; bool:\n            filename = os.path.basename(path)\n            return filename.endswith((\".yaml\", \".yml\"))\n\n        self._canonicalize(\"dockerfile\")\n        self._canonicalize(\"build_context\")\n        self._canonicalize(\"spec\")\n\n        if self.spec is None and self.dockerfile is None:\n            raise ValueError(\"Must specify either image spec or Dockerfile\")\n\n        if self.spec is not None and self.dockerfile is not None:\n            raise ValueError(\"Cannot specify both image spec and Dockerfile\")\n\n        if self.spec is not None and not _is_yaml(self.spec):\n            raise ValueError(f\"Container image spec is not a YAML file: {self.spec}\")\n\n        if not self.build_context.is_dir():\n            raise ValueError(f\"Build context must be a directory: {self.build_context}\")\n\n        if self.dockerfile is not None and not self.dockerfile.is_relative_to(\n            self.build_context\n        ):\n            raise ValueError(\n                f\"Dockerfile must be relative to build context {self.build_context}\"\n            )\n</code></pre>"},{"location":"reference/jobs/#jobs.ImageOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>src/jobs/job.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/jobs/#jobs.ImageOptions.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>src/jobs/job.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/jobs/#jobs.ImageOptions.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of ImageOptions from a JSON string</p> Source code in <code>src/jobs/job.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of ImageOptions from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/jobs/#jobs.ImageOptions.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>src/jobs/job.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: AbstractSet[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # set to None if name (nullable) is None\n    # and model_fields_set contains the field\n    if self.name is None and \"name\" in self.model_fields_set:\n        _dict[\"name\"] = None\n\n    # set to None if spec (nullable) is None\n    # and model_fields_set contains the field\n    if self.spec is None and \"spec\" in self.model_fields_set:\n        _dict[\"spec\"] = None\n\n    # set to None if dockerfile (nullable) is None\n    # and model_fields_set contains the field\n    if self.dockerfile is None and \"dockerfile\" in self.model_fields_set:\n        _dict[\"dockerfile\"] = None\n\n    return _dict\n</code></pre>"},{"location":"reference/jobs/#jobs.ImageOptions.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of ImageOptions from a dict</p> Source code in <code>src/jobs/job.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of ImageOptions from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"name\": obj.get(\"name\"),\n        \"tag\": obj.get(\"tag\") if obj.get(\"tag\") is not None else \"latest\",\n        \"spec\": obj.get(\"spec\"),\n        \"dockerfile\": obj.get(\"dockerfile\"),\n        \"build_context\": obj.get(\"build_context\")\n        if obj.get(\"build_context\") is not None\n        else \"/Users/adriano/work/docker-job-poc/backend\",\n    })\n    return _obj\n</code></pre>"},{"location":"reference/jobs/#jobs.Job","title":"Job","text":"<p>               Bases: <code>Generic[P, T]</code></p> Source code in <code>src/jobs/job.py</code> <pre><code>class Job(Generic[P, T]):\n    def __init__(\n        self,\n        func: Callable[P, T],\n        *,\n        options: JobOptions | None = None,\n        image: ImageOptions | None = None,\n    ) -&gt; None:\n        functools.update_wrapper(self, func)\n        self._func = func\n        self.options = options\n        self.image = image\n\n        if (module := inspect.getmodule(self._func)) is None:\n            raise ValueError(\"Cannot derive module for Job function.\")\n\n        self._name = self._func.__name__\n        self._file = os.path.relpath(str(module.__file__))\n\n        self.validate()\n\n    @property\n    def name(self) -&gt; str:\n        return self._name\n\n    @property\n    def file(self) -&gt; str:\n        return self._file\n\n    def __call__(self, *args: P.args, **kwargs: P.kwargs) -&gt; T:\n        return self._func(*args, **kwargs)\n\n    def _render_dockerfile(self) -&gt; str:\n        \"\"\"Render the job's Dockerfile from a YAML spec.\"\"\"\n\n        if not (self.image):\n            raise ValueError(\"Container image options must be specified\")\n\n        image_spec = self.image.spec\n        if not image_spec:\n            raise ValueError(\"Container image spec must be specified\")\n\n        if not image_spec.is_file():\n            raise FileNotFoundError(\n                f\"Container image spec file not found: {image_spec.is_file()}\"\n            )\n\n        image_cfg = config.load_config(image_spec)\n\n        renderers = [cls(image_cfg) for cls in RENDERERS if cls.accepts(image_cfg)]\n        dockerfile_content = \"\"\n        for r in renderers:\n            dockerfile_content += r.render() + \"\\n\"\n        return dockerfile_content\n\n    def validate(self) -&gt; None:\n        if self.options:\n            validate_labels(self.options.labels)\n\n    def build_image(\n        self,\n        push: bool = False,\n    ) -&gt; Image | None:\n        if not self.image:\n            raise ValueError(\"Need image options to build image\")\n        opts = self.image\n\n        tag = f\"{opts.name or self.name}:{opts.tag}\"\n\n        logging.info(f\"Building container image: {tag!r}\")\n\n        build_cmd = [\"docker\", \"build\", \"-t\", tag]\n        labels = self.options.labels if self.options else {}\n        build_cmd.extend([f\"--label={k}={v}\" for k, v in labels.items()])\n\n        exit_code: int = -1\n        if opts.build_mode == BuildMode.YAML:\n            yaml = self._render_dockerfile()\n            with io.StringIO(yaml) as dockerfile:\n                build_cmd.extend([\"-f-\", f\"{opts.build_context.absolute()}\"])\n                exit_code, _, _, _ = run_command(\n                    shlex.join(build_cmd),\n                    stdin=dockerfile,\n                    verbose=True,\n                )\n        elif opts.build_mode == BuildMode.DOCKERFILE:\n            if opts.dockerfile is None:\n                raise ValueError(\"Dockerfile path must be specified\")\n            if not opts.dockerfile.is_file():\n                raise FileNotFoundError(\n                    f\"Specified Dockerfile not found: {opts.dockerfile.absolute()}\"\n                )\n            build_cmd.extend([\n                \"-f\",\n                f\"{opts.dockerfile}\",\n                f\"{opts.build_context.absolute()}\",\n            ])\n            exit_code, _, _, _ = run_command(\n                shlex.join(build_cmd),\n                verbose=True,\n            )\n\n        if exit_code == 0:\n            if push:\n                logging.info(\"Pushing container image to remote registry\")\n                exit_code, _, _, _ = run_command(\n                    f\"docker push {tag}\",\n                    verbose=True,\n                )\n                if exit_code != 0:\n                    return None\n\n            return Image(tag)\n        else:\n            return None\n</code></pre>"},{"location":"reference/jobs/#jobs.JobOptions","title":"JobOptions","text":"<p>               Bases: <code>JsonSerializable</code>, <code>DictSerializable</code>, <code>BaseModel</code></p> <p>JobOptions</p> Source code in <code>src/jobs/job.py</code> <pre><code>class JobOptions(JsonSerializable, DictSerializable, BaseModel):\n    \"\"\"\n    JobOptions\n    \"\"\"  # noqa: E501\n\n    resources: ResourceOptions | None = None\n    scheduling: SchedulingOptions | None = None\n    labels: dict[str, StrictStr] = Field(default_factory=dict)\n    __properties: ClassVar[list[str]] = [\"resources\", \"scheduling\", \"labels\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/jobs/#jobs.JobOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>src/jobs/job.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/jobs/#jobs.ResourceOptions","title":"ResourceOptions","text":"<p>               Bases: <code>JsonSerializable</code>, <code>DictSerializable</code>, <code>BaseModel</code></p> <p>ResourceOptions</p> Source code in <code>src/jobs/job.py</code> <pre><code>class ResourceOptions(JsonSerializable, DictSerializable, BaseModel):\n    \"\"\"\n    ResourceOptions\n    \"\"\"  # noqa: E501\n\n    memory: StrictStr | None = None\n    cpu: StrictStr | None = None\n    gpu: StrictInt | None = None\n    __properties: ClassVar[list[str]] = [\"memory\", \"cpu\", \"gpu\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_docker(self) -&gt; DockerResourceOptions:\n        options: DockerResourceOptions = {\n            \"mem_limit\": str(int(to_rational(self.memory))) if self.memory else None,\n            \"nano_cpus\": int(to_rational(self.cpu) * 10**9) if self.cpu else None,\n            \"device_requests\": (\n                [\n                    docker.types.DeviceRequest(\n                        capabilities=[[\"gpu\"]],\n                        count=self.gpu,\n                    )\n                ]\n                if self.gpu\n                else None\n            ),\n        }\n        return remove_none_values(options)\n\n    def to_kubernetes(\n        self, kind: K8sResourceKind = K8sResourceKind.REQUESTS\n    ) -&gt; K8sResourceOptions:\n        # TODO: Currently kind is not accessed and the logic for \"request\" and \"limit\" is the same.\n        # Down the road we have to decide if we want to keep it that way (and get rid of the distinction and arguments),\n        # or if it makes sense for us to distinguish both cases.\n        options: K8sResourceOptions = {\n            \"cpu\": self.cpu or None,\n            \"memory\": self.memory or None,\n            \"nvidia.com/gpu\": self.gpu or None,\n        }\n        return remove_none_values(options)\n\n    def to_ray(self) -&gt; RayResourceOptions:\n        options: RayResourceOptions = {\n            \"entrypoint_memory\": int(to_rational(self.memory)) if self.memory else None,\n            \"entrypoint_num_cpus\": int(to_rational(self.cpu)) if self.cpu else None,\n            \"entrypoint_num_gpus\": self.gpu or None,\n        }\n        return remove_none_values(options)\n</code></pre>"},{"location":"reference/jobs/#jobs.ResourceOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>src/jobs/job.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/jobs/#jobs.SchedulingOptions","title":"SchedulingOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>SchedulingOptions</p> Source code in <code>src/jobs/job.py</code> <pre><code>class SchedulingOptions(BaseModel):\n    \"\"\"\n    SchedulingOptions\n    \"\"\"  # noqa: E501\n\n    priority_class: StrictStr | None = None\n    queue_name: StrictStr | None = None\n    __properties: ClassVar[list[str]] = [\"priority_class\", \"queue_name\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of SchedulingOptions from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: AbstractSet[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # set to None if priority_class (nullable) is None\n        # and model_fields_set contains the field\n        if self.priority_class is None and \"priority_class\" in self.model_fields_set:\n            _dict[\"priority_class\"] = None\n\n        # set to None if queue_name (nullable) is None\n        # and model_fields_set contains the field\n        if self.queue_name is None and \"queue_name\" in self.model_fields_set:\n            _dict[\"queue_name\"] = None\n\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of SchedulingOptions from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"priority_class\": obj.get(\"priority_class\"),\n            \"queue_name\": obj.get(\"queue_name\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/jobs/#jobs.SchedulingOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>src/jobs/job.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/jobs/#jobs.SchedulingOptions.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>src/jobs/job.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/jobs/#jobs.SchedulingOptions.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of SchedulingOptions from a JSON string</p> Source code in <code>src/jobs/job.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of SchedulingOptions from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/jobs/#jobs.SchedulingOptions.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>src/jobs/job.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: AbstractSet[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # set to None if priority_class (nullable) is None\n    # and model_fields_set contains the field\n    if self.priority_class is None and \"priority_class\" in self.model_fields_set:\n        _dict[\"priority_class\"] = None\n\n    # set to None if queue_name (nullable) is None\n    # and model_fields_set contains the field\n    if self.queue_name is None and \"queue_name\" in self.model_fields_set:\n        _dict[\"queue_name\"] = None\n\n    return _dict\n</code></pre>"},{"location":"reference/jobs/#jobs.SchedulingOptions.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of SchedulingOptions from a dict</p> Source code in <code>src/jobs/job.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of SchedulingOptions from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"priority_class\": obj.get(\"priority_class\"),\n        \"queue_name\": obj.get(\"queue_name\"),\n    })\n    return _obj\n</code></pre>"},{"location":"reference/jobs/#modules","title":"Modules","text":""},{"location":"reference/jobs/#assembler","title":"assembler","text":""},{"location":"reference/jobs/#cli","title":"cli","text":""},{"location":"reference/jobs/#execute","title":"execute","text":""},{"location":"reference/jobs/#image","title":"image","text":""},{"location":"reference/jobs/#job","title":"job","text":""},{"location":"reference/jobs/#submission_context","title":"submission_context","text":""},{"location":"reference/jobs/#types","title":"types","text":""},{"location":"reference/jobs/#utils","title":"utils","text":""},{"location":"reference/jobs/#api","title":"api","text":""},{"location":"reference/jobs/#api_client","title":"api_client","text":"<p>infrastructure-product API</p>"},{"location":"reference/jobs/#api_response","title":"api_response","text":"<p>API response object.</p>"},{"location":"reference/jobs/#configuration","title":"configuration","text":"<p>infrastructure-product API</p>"},{"location":"reference/jobs/#exceptions","title":"exceptions","text":"<p>infrastructure-product API</p>"},{"location":"reference/jobs/#models","title":"models","text":"<p>infrastructure-product API</p>"},{"location":"reference/jobs/#rest","title":"rest","text":"<p>infrastructure-product API</p>"},{"location":"reference/jobs/#test","title":"test","text":""},{"location":"reference/jobs/cli/","title":"cli","text":""},{"location":"reference/jobs/cli/#jobs.cli.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>CLI entrypoint for job submission</p> Source code in <code>src/jobs/cli.py</code> <pre><code>def main():\n    \"\"\"CLI entrypoint for job submission\"\"\"\n\n    logging.basicConfig(level=logging.DEBUG)\n    logging.getLogger(\"urllib3.connectionpool\").setLevel(logging.INFO)\n\n    args = _make_argparser().parse_args()\n    args.func(args)\n</code></pre>"},{"location":"reference/jobs/execute/","title":"execute","text":""},{"location":"reference/jobs/image/","title":"image","text":""},{"location":"reference/jobs/job/","title":"job","text":""},{"location":"reference/jobs/job/#jobs.job.ImageOptions","title":"ImageOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>ImageOptions</p> Source code in <code>src/jobs/job.py</code> <pre><code>class ImageOptions(BaseModel):\n    \"\"\"\n    ImageOptions\n    \"\"\"  # noqa: E501\n\n    name: StrictStr | None = None\n    tag: StrictStr | None = \"latest\"\n    spec: Path | None = None\n    dockerfile: Path | None = None\n    build_context: Path = (\n        Path.cwd()\n    )  # FIXME: Maybe don't have a default here but rather only set it at build time\n    __properties: ClassVar[list[str]] = [\n        \"name\",\n        \"tag\",\n        \"spec\",\n        \"dockerfile\",\n        \"build_context\",\n    ]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of ImageOptions from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: AbstractSet[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # set to None if name (nullable) is None\n        # and model_fields_set contains the field\n        if self.name is None and \"name\" in self.model_fields_set:\n            _dict[\"name\"] = None\n\n        # set to None if spec (nullable) is None\n        # and model_fields_set contains the field\n        if self.spec is None and \"spec\" in self.model_fields_set:\n            _dict[\"spec\"] = None\n\n        # set to None if dockerfile (nullable) is None\n        # and model_fields_set contains the field\n        if self.dockerfile is None and \"dockerfile\" in self.model_fields_set:\n            _dict[\"dockerfile\"] = None\n\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of ImageOptions from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"name\": obj.get(\"name\"),\n            \"tag\": obj.get(\"tag\") if obj.get(\"tag\") is not None else \"latest\",\n            \"spec\": obj.get(\"spec\"),\n            \"dockerfile\": obj.get(\"dockerfile\"),\n            \"build_context\": obj.get(\"build_context\")\n            if obj.get(\"build_context\") is not None\n            else \"/Users/adriano/work/docker-job-poc/backend\",\n        })\n        return _obj\n\n    @property\n    def build_mode(self) -&gt; BuildMode:\n        if self.spec is not None:\n            return BuildMode.YAML\n        elif self.dockerfile is not None:\n            return BuildMode.DOCKERFILE\n        else:\n            raise ValueError(\n                \"error building image: either YAML spec or Dockerfile must be set.\"\n            )\n\n    def _canonicalize(self, attr: str) -&gt; Path | None:\n        path = self.__getattribute__(attr)\n\n        if path is None:\n            return None\n\n        if not isinstance(path, str | Path):\n            raise TypeError(f\"Expected {attr!r} to be a str or Path, got: {type(path)}\")\n\n        if isinstance(path, str):\n            path = Path(path)\n\n        canonical_path = path.resolve()\n        object.__setattr__(self, attr, canonical_path)\n\n        return canonical_path\n\n    def model_post_init(self, /, __context: Any) -&gt; None:\n        def _is_yaml(path: AnyPath) -&gt; bool:\n            filename = os.path.basename(path)\n            return filename.endswith((\".yaml\", \".yml\"))\n\n        self._canonicalize(\"dockerfile\")\n        self._canonicalize(\"build_context\")\n        self._canonicalize(\"spec\")\n\n        if self.spec is None and self.dockerfile is None:\n            raise ValueError(\"Must specify either image spec or Dockerfile\")\n\n        if self.spec is not None and self.dockerfile is not None:\n            raise ValueError(\"Cannot specify both image spec and Dockerfile\")\n\n        if self.spec is not None and not _is_yaml(self.spec):\n            raise ValueError(f\"Container image spec is not a YAML file: {self.spec}\")\n\n        if not self.build_context.is_dir():\n            raise ValueError(f\"Build context must be a directory: {self.build_context}\")\n\n        if self.dockerfile is not None and not self.dockerfile.is_relative_to(\n            self.build_context\n        ):\n            raise ValueError(\n                f\"Dockerfile must be relative to build context {self.build_context}\"\n            )\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.ImageOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>src/jobs/job.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.ImageOptions.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>src/jobs/job.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.ImageOptions.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of ImageOptions from a JSON string</p> Source code in <code>src/jobs/job.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of ImageOptions from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.ImageOptions.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>src/jobs/job.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: AbstractSet[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # set to None if name (nullable) is None\n    # and model_fields_set contains the field\n    if self.name is None and \"name\" in self.model_fields_set:\n        _dict[\"name\"] = None\n\n    # set to None if spec (nullable) is None\n    # and model_fields_set contains the field\n    if self.spec is None and \"spec\" in self.model_fields_set:\n        _dict[\"spec\"] = None\n\n    # set to None if dockerfile (nullable) is None\n    # and model_fields_set contains the field\n    if self.dockerfile is None and \"dockerfile\" in self.model_fields_set:\n        _dict[\"dockerfile\"] = None\n\n    return _dict\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.ImageOptions.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of ImageOptions from a dict</p> Source code in <code>src/jobs/job.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of ImageOptions from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"name\": obj.get(\"name\"),\n        \"tag\": obj.get(\"tag\") if obj.get(\"tag\") is not None else \"latest\",\n        \"spec\": obj.get(\"spec\"),\n        \"dockerfile\": obj.get(\"dockerfile\"),\n        \"build_context\": obj.get(\"build_context\")\n        if obj.get(\"build_context\") is not None\n        else \"/Users/adriano/work/docker-job-poc/backend\",\n    })\n    return _obj\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.ResourceOptions","title":"ResourceOptions","text":"<p>               Bases: <code>JsonSerializable</code>, <code>DictSerializable</code>, <code>BaseModel</code></p> <p>ResourceOptions</p> Source code in <code>src/jobs/job.py</code> <pre><code>class ResourceOptions(JsonSerializable, DictSerializable, BaseModel):\n    \"\"\"\n    ResourceOptions\n    \"\"\"  # noqa: E501\n\n    memory: StrictStr | None = None\n    cpu: StrictStr | None = None\n    gpu: StrictInt | None = None\n    __properties: ClassVar[list[str]] = [\"memory\", \"cpu\", \"gpu\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_docker(self) -&gt; DockerResourceOptions:\n        options: DockerResourceOptions = {\n            \"mem_limit\": str(int(to_rational(self.memory))) if self.memory else None,\n            \"nano_cpus\": int(to_rational(self.cpu) * 10**9) if self.cpu else None,\n            \"device_requests\": (\n                [\n                    docker.types.DeviceRequest(\n                        capabilities=[[\"gpu\"]],\n                        count=self.gpu,\n                    )\n                ]\n                if self.gpu\n                else None\n            ),\n        }\n        return remove_none_values(options)\n\n    def to_kubernetes(\n        self, kind: K8sResourceKind = K8sResourceKind.REQUESTS\n    ) -&gt; K8sResourceOptions:\n        # TODO: Currently kind is not accessed and the logic for \"request\" and \"limit\" is the same.\n        # Down the road we have to decide if we want to keep it that way (and get rid of the distinction and arguments),\n        # or if it makes sense for us to distinguish both cases.\n        options: K8sResourceOptions = {\n            \"cpu\": self.cpu or None,\n            \"memory\": self.memory or None,\n            \"nvidia.com/gpu\": self.gpu or None,\n        }\n        return remove_none_values(options)\n\n    def to_ray(self) -&gt; RayResourceOptions:\n        options: RayResourceOptions = {\n            \"entrypoint_memory\": int(to_rational(self.memory)) if self.memory else None,\n            \"entrypoint_num_cpus\": int(to_rational(self.cpu)) if self.cpu else None,\n            \"entrypoint_num_gpus\": self.gpu or None,\n        }\n        return remove_none_values(options)\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.ResourceOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>src/jobs/job.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.SchedulingOptions","title":"SchedulingOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>SchedulingOptions</p> Source code in <code>src/jobs/job.py</code> <pre><code>class SchedulingOptions(BaseModel):\n    \"\"\"\n    SchedulingOptions\n    \"\"\"  # noqa: E501\n\n    priority_class: StrictStr | None = None\n    queue_name: StrictStr | None = None\n    __properties: ClassVar[list[str]] = [\"priority_class\", \"queue_name\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of SchedulingOptions from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: AbstractSet[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # set to None if priority_class (nullable) is None\n        # and model_fields_set contains the field\n        if self.priority_class is None and \"priority_class\" in self.model_fields_set:\n            _dict[\"priority_class\"] = None\n\n        # set to None if queue_name (nullable) is None\n        # and model_fields_set contains the field\n        if self.queue_name is None and \"queue_name\" in self.model_fields_set:\n            _dict[\"queue_name\"] = None\n\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of SchedulingOptions from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"priority_class\": obj.get(\"priority_class\"),\n            \"queue_name\": obj.get(\"queue_name\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.SchedulingOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>src/jobs/job.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.SchedulingOptions.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>src/jobs/job.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.SchedulingOptions.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of SchedulingOptions from a JSON string</p> Source code in <code>src/jobs/job.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of SchedulingOptions from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.SchedulingOptions.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>src/jobs/job.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: AbstractSet[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # set to None if priority_class (nullable) is None\n    # and model_fields_set contains the field\n    if self.priority_class is None and \"priority_class\" in self.model_fields_set:\n        _dict[\"priority_class\"] = None\n\n    # set to None if queue_name (nullable) is None\n    # and model_fields_set contains the field\n    if self.queue_name is None and \"queue_name\" in self.model_fields_set:\n        _dict[\"queue_name\"] = None\n\n    return _dict\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.SchedulingOptions.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of SchedulingOptions from a dict</p> Source code in <code>src/jobs/job.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of SchedulingOptions from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"priority_class\": obj.get(\"priority_class\"),\n        \"queue_name\": obj.get(\"queue_name\"),\n    })\n    return _obj\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.JobOptions","title":"JobOptions","text":"<p>               Bases: <code>JsonSerializable</code>, <code>DictSerializable</code>, <code>BaseModel</code></p> <p>JobOptions</p> Source code in <code>src/jobs/job.py</code> <pre><code>class JobOptions(JsonSerializable, DictSerializable, BaseModel):\n    \"\"\"\n    JobOptions\n    \"\"\"  # noqa: E501\n\n    resources: ResourceOptions | None = None\n    scheduling: SchedulingOptions | None = None\n    labels: dict[str, StrictStr] = Field(default_factory=dict)\n    __properties: ClassVar[list[str]] = [\"resources\", \"scheduling\", \"labels\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.JobOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>src/jobs/job.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.Job","title":"Job","text":"<p>               Bases: <code>Generic[P, T]</code></p> Source code in <code>src/jobs/job.py</code> <pre><code>class Job(Generic[P, T]):\n    def __init__(\n        self,\n        func: Callable[P, T],\n        *,\n        options: JobOptions | None = None,\n        image: ImageOptions | None = None,\n    ) -&gt; None:\n        functools.update_wrapper(self, func)\n        self._func = func\n        self.options = options\n        self.image = image\n\n        if (module := inspect.getmodule(self._func)) is None:\n            raise ValueError(\"Cannot derive module for Job function.\")\n\n        self._name = self._func.__name__\n        self._file = os.path.relpath(str(module.__file__))\n\n        self.validate()\n\n    @property\n    def name(self) -&gt; str:\n        return self._name\n\n    @property\n    def file(self) -&gt; str:\n        return self._file\n\n    def __call__(self, *args: P.args, **kwargs: P.kwargs) -&gt; T:\n        return self._func(*args, **kwargs)\n\n    def _render_dockerfile(self) -&gt; str:\n        \"\"\"Render the job's Dockerfile from a YAML spec.\"\"\"\n\n        if not (self.image):\n            raise ValueError(\"Container image options must be specified\")\n\n        image_spec = self.image.spec\n        if not image_spec:\n            raise ValueError(\"Container image spec must be specified\")\n\n        if not image_spec.is_file():\n            raise FileNotFoundError(\n                f\"Container image spec file not found: {image_spec.is_file()}\"\n            )\n\n        image_cfg = config.load_config(image_spec)\n\n        renderers = [cls(image_cfg) for cls in RENDERERS if cls.accepts(image_cfg)]\n        dockerfile_content = \"\"\n        for r in renderers:\n            dockerfile_content += r.render() + \"\\n\"\n        return dockerfile_content\n\n    def validate(self) -&gt; None:\n        if self.options:\n            validate_labels(self.options.labels)\n\n    def build_image(\n        self,\n        push: bool = False,\n    ) -&gt; Image | None:\n        if not self.image:\n            raise ValueError(\"Need image options to build image\")\n        opts = self.image\n\n        tag = f\"{opts.name or self.name}:{opts.tag}\"\n\n        logging.info(f\"Building container image: {tag!r}\")\n\n        build_cmd = [\"docker\", \"build\", \"-t\", tag]\n        labels = self.options.labels if self.options else {}\n        build_cmd.extend([f\"--label={k}={v}\" for k, v in labels.items()])\n\n        exit_code: int = -1\n        if opts.build_mode == BuildMode.YAML:\n            yaml = self._render_dockerfile()\n            with io.StringIO(yaml) as dockerfile:\n                build_cmd.extend([\"-f-\", f\"{opts.build_context.absolute()}\"])\n                exit_code, _, _, _ = run_command(\n                    shlex.join(build_cmd),\n                    stdin=dockerfile,\n                    verbose=True,\n                )\n        elif opts.build_mode == BuildMode.DOCKERFILE:\n            if opts.dockerfile is None:\n                raise ValueError(\"Dockerfile path must be specified\")\n            if not opts.dockerfile.is_file():\n                raise FileNotFoundError(\n                    f\"Specified Dockerfile not found: {opts.dockerfile.absolute()}\"\n                )\n            build_cmd.extend([\n                \"-f\",\n                f\"{opts.dockerfile}\",\n                f\"{opts.build_context.absolute()}\",\n            ])\n            exit_code, _, _, _ = run_command(\n                shlex.join(build_cmd),\n                verbose=True,\n            )\n\n        if exit_code == 0:\n            if push:\n                logging.info(\"Pushing container image to remote registry\")\n                exit_code, _, _, _ = run_command(\n                    f\"docker push {tag}\",\n                    verbose=True,\n                )\n                if exit_code != 0:\n                    return None\n\n            return Image(tag)\n        else:\n            return None\n</code></pre>"},{"location":"reference/jobs/job/#jobs.job.validate_labels","title":"validate_labels","text":"<pre><code>validate_labels(labels: dict[str, str]) -&gt; None\n</code></pre> <p>Validate the syntactic correctness of user-specified job labels.</p> <p>Note that the rules for labels are the intersection (i.e., the strictest subset) of syntax restrictions on Docker labels and Kubernetes annotations, so that the labels can be applied in either context.</p> <p>See the following documents for further reference: - Docker: https://docs.docker.com/config/labels-custom-metadata/#value-guidelines - Kubernetes: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set</p> RAISES DESCRIPTION <code>ValueError</code> <p>if the labels are not well-formed</p> Source code in <code>src/jobs/job.py</code> <pre><code>def validate_labels(labels: dict[str, str]) -&gt; None:\n    \"\"\"Validate the syntactic correctness of user-specified job labels.\n\n    Note that the rules for labels are the intersection (i.e., the strictest subset)\n    of syntax restrictions on Docker labels and Kubernetes annotations, so that the\n    labels can be applied in either context.\n\n    See the following documents for further reference:\n    - Docker: &lt;https://docs.docker.com/config/labels-custom-metadata/#value-guidelines&gt;\n    - Kubernetes: &lt;https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set&gt;\n\n    Raises\n    ------\n    ValueError\n        if the labels are not well-formed\n    \"\"\"\n    for k, v in labels.items():\n        # Label keys:\n        # - Must start and end with a letter\n        # - Can contain dashes (-), underscores (_), dots (.), slashes (/), and alphanumerics between.\n        # - May not contain prefixes (as used in Kubernetes), since they are not compatible with Docker\n        if not re.match(r\"^[a-z]+(?:[/._-][a-z0-9]+)*[a-z]?$\", k):\n            raise ValueError(f\"Label key is not well-formed: {k}\")\n\n        # Label values:\n        # - Maximum length of 127 characters\n        if len(v) &gt; 127:\n            raise ValueError(f\"Label value is not well-formed: {v}\")\n</code></pre>"},{"location":"reference/jobs/submission_context/","title":"submission_context","text":""},{"location":"reference/jobs/types/","title":"types","text":""},{"location":"reference/jobs/types/#jobs.types.JsonSerializable","title":"JsonSerializable","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin to mark a Pydantic model that can be (de-)serialized to JSON</p> Source code in <code>src/jobs/types.py</code> <pre><code>class JsonSerializable(BaseModel):\n    \"\"\"Mixin to mark a Pydantic model that can be (de-)serialized to JSON\"\"\"\n\n    def to_json(self) -&gt; str:\n        return self.model_dump_json(by_alias=True, exclude_unset=True)\n\n    @classmethod\n    def from_json(cls, json_data: str) -&gt; Self:\n        return cls.model_validate_json(json_data)\n</code></pre>"},{"location":"reference/jobs/types/#jobs.types.DictSerializable","title":"DictSerializable","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin to mark a Pydantic model that can be (de-)serialized to a Python dict</p> Source code in <code>src/jobs/types.py</code> <pre><code>class DictSerializable(BaseModel):\n    \"\"\"Mixin to mark a Pydantic model that can be (de-)serialized to a Python dict\"\"\"\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        return self.model_dump(by_alias=True, exclude_none=True)\n\n    @classmethod\n    def from_dict(cls, obj: Any) -&gt; Self:\n        return cls.model_validate(obj)\n</code></pre>"},{"location":"reference/jobs/assembler/","title":"assembler","text":""},{"location":"reference/jobs/assembler/config/","title":"config","text":""},{"location":"reference/jobs/assembler/renderers/","title":"renderers","text":""},{"location":"reference/jobs/utils/","title":"utils","text":""},{"location":"reference/jobs/utils/helpers/","title":"helpers","text":""},{"location":"reference/jobs/utils/helpers/#jobs.utils.helpers.remove_none_values","title":"remove_none_values","text":"<pre><code>remove_none_values(d: T) -&gt; T\n</code></pre> <p>Remove all keys with a <code>None</code> value from a dict.</p> Source code in <code>src/jobs/utils/helpers.py</code> <pre><code>def remove_none_values(d: T) -&gt; T:\n    \"\"\"Remove all keys with a ``None`` value from a dict.\"\"\"\n    filtered_dict = {k: v for k, v in d.items() if v is not None}\n    return cast(T, filtered_dict)\n</code></pre>"},{"location":"reference/jobs/utils/math/","title":"math","text":""},{"location":"reference/jobs/utils/math/#jobs.utils.math.to_rational","title":"to_rational","text":"<pre><code>to_rational(s: str) -&gt; float\n</code></pre> <p>Convert a number with optional SI/binary unit to floating-point</p> Source code in <code>src/jobs/utils/math.py</code> <pre><code>def to_rational(s: str) -&gt; float:\n    \"\"\"Convert a number with optional SI/binary unit to floating-point\"\"\"\n\n    matches = re.match(r\"(?P&lt;magnitude&gt;[+\\-]?\\d*[.,]?\\d+)(?P&lt;suffix&gt;[a-zA-Z]*)\", s)\n    if not matches:\n        raise ValueError(f\"Could not parse {s}\")\n    magnitude = float(matches.group(\"magnitude\"))\n    suffix = matches.group(\"suffix\")\n\n    factor = {\n        # SI / Metric\n        \"m\": 1e-3,\n        \"k\": 1e3,\n        \"M\": 1e6,\n        \"G\": 1e9,\n        \"T\": 1e12,\n        # Binary\n        \"Ki\": 2**10,\n        \"Mi\": 2**20,\n        \"Gi\": 2**30,\n        \"Ti\": 2**40,\n        # default\n        \"\": 1.0,\n    }.get(suffix)\n    if factor is None:\n        raise ValueError(f\"unknown unit suffix: {suffix}\")\n\n    return factor * magnitude\n</code></pre>"},{"location":"reference/jobs/utils/processes/","title":"processes","text":""},{"location":"reference/jobs/utils/processes/#jobs.utils.processes.run_command","title":"run_command","text":"<pre><code>run_command(\n    command: str,\n    cwd: AnyPath | None = None,\n    verbose: bool = False,\n    env: Mapping[str, str] | None = None,\n    stdin: TextIO | None = None,\n) -&gt; tuple[int, list[str], list[str], list[str]]\n</code></pre> <p>Run a command in a subprocess.</p> PARAMETER DESCRIPTION <code>command</code> <p>Command to run</p> <p> TYPE: <code>str</code> </p> <code>cwd</code> <p>Working directory</p> <p> TYPE: <code>PathLike[str] | Path | None</code> DEFAULT: <code>None</code> </p> <code>verbose</code> <p>Forward command output to stdout/stderr</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>env</code> <p>Environment for the new process, by default the current environment</p> <p> TYPE: <code>dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>stdin</code> <p>Standard input for the new process, by default <code>None</code></p> <p> TYPE: <code>BinaryIO | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>tuple[int, list[str], list[str], list[str]]</code> <p>a tuple containing the return code and the output of the command (stdout, stderr, and combined)</p> Source code in <code>src/jobs/utils/processes.py</code> <pre><code>def run_command(\n    command: str,\n    cwd: AnyPath | None = None,\n    verbose: bool = False,\n    env: Mapping[str, str] | None = None,\n    stdin: TextIO | None = None,\n) -&gt; tuple[int, list[str], list[str], list[str]]:\n    \"\"\"Run a command in a subprocess.\n\n    Parameters\n    ----------\n    command : str\n        Command to run\n    cwd : os.PathLike[str] | Path | None, optional\n        Working directory\n    verbose : bool, optional\n        Forward command output to stdout/stderr\n    env : dict[str, str], optional\n        Environment for the new process, by default the current environment\n    stdin : BinaryIO | None, optional\n        Standard input for the new process, by default `None`\n\n    Returns\n    -------\n    tuple[int, list[str], list[str], list[str]]\n        a tuple containing the return code and the output of the command (stdout, stderr, and combined)\n    \"\"\"\n\n    logging.debug(\"Running command: %s\", command)\n    # No need to split the command string on Windows\n    if sys.platform == \"win32\":\n        args = command\n    else:\n        args = shlex.split(command)\n\n    process = subprocess.Popen(\n        args=args,\n        stdin=subprocess.PIPE if stdin else None,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        cwd=cwd,\n        env=env,\n        encoding=\"utf-8\",\n    )\n\n    if stdin is not None and process.stdin:\n        process.stdin.write(stdin.read())\n        process.stdin.close()\n\n    # Capture stdout and stderr\n    stdout: list[str] = []\n    stderr: list[str] = []\n    output: list[str] = []\n\n    def _reader(\n        in_stream: TextIO | None,\n        out_stream: TextIOBase,\n        out_lists: Iterable[list[str]],\n    ) -&gt; None:\n        if in_stream is None:\n            return\n        for line in in_stream:\n            for out in out_lists:\n                out.append(line)\n\n            if verbose:\n                out_stream.write(line)\n                out_stream.flush()\n\n    read_stdout = threading.Thread(\n        target=_reader,\n        kwargs={\n            \"in_stream\": process.stdout,\n            \"out_stream\": sys.stdout,\n            \"out_lists\": [stdout, output],\n        },\n    )\n    read_stderr = threading.Thread(\n        target=_reader,\n        kwargs={\n            \"in_stream\": process.stderr,\n            \"out_stream\": sys.stderr,\n            \"out_lists\": [stderr, output],\n        },\n    )\n\n    read_stdout.start()\n    read_stderr.start()\n\n    # Wait for process to finish\n    while process.poll() is None:\n        time.sleep(0.1)\n\n    read_stdout.join()\n    read_stderr.join()\n\n    return process.returncode, stdout, stderr, output\n</code></pre>"},{"location":"reference/openapi_client/","title":"openapi_client","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/api_client/","title":"api_client","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient","title":"ApiClient","text":"<p>Generic API client for OpenAPI client library builds.</p> <p>OpenAPI generic API client. This client handles the client- server communication, and is invariant across implementations. Specifics of the methods and models for each application are generated from the OpenAPI templates.</p> <p>:param configuration: .Configuration object for this client :param header_name: a header to pass when making calls to the API. :param header_value: a header value to pass when making calls to     the API. :param cookie: a cookie to include in the header when making calls     to the API</p> Source code in <code>src/openapi_client/api_client.py</code> <pre><code>class ApiClient:\n    \"\"\"Generic API client for OpenAPI client library builds.\n\n    OpenAPI generic API client. This client handles the client-\n    server communication, and is invariant across implementations. Specifics of\n    the methods and models for each application are generated from the OpenAPI\n    templates.\n\n    :param configuration: .Configuration object for this client\n    :param header_name: a header to pass when making calls to the API.\n    :param header_value: a header value to pass when making calls to\n        the API.\n    :param cookie: a cookie to include in the header when making calls\n        to the API\n    \"\"\"\n\n    PRIMITIVE_TYPES = (float, bool, bytes, str, int)\n    NATIVE_TYPES_MAPPING = {\n        \"int\": int,\n        \"long\": int,  # TODO remove as only py3 is supported?\n        \"float\": float,\n        \"str\": str,\n        \"bool\": bool,\n        \"date\": datetime.date,\n        \"datetime\": datetime.datetime,\n        \"decimal\": decimal.Decimal,\n        \"object\": object,\n    }\n    _pool = None\n\n    def __init__(\n        self, configuration=None, header_name=None, header_value=None, cookie=None\n    ) -&gt; None:\n        # use default configuration if none is provided\n        if configuration is None:\n            configuration = Configuration.get_default()\n        self.configuration = configuration\n\n        self.rest_client = rest.RESTClientObject(configuration)\n        self.default_headers = {}\n        if header_name is not None:\n            self.default_headers[header_name] = header_value\n        self.cookie = cookie\n        # Set default User-Agent.\n        self.user_agent = \"OpenAPI-Generator/1.0.0/python\"\n        self.client_side_validation = configuration.client_side_validation\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        pass\n\n    @property\n    def user_agent(self):\n        \"\"\"User agent for this API client\"\"\"\n        return self.default_headers[\"User-Agent\"]\n\n    @user_agent.setter\n    def user_agent(self, value):\n        self.default_headers[\"User-Agent\"] = value\n\n    def set_default_header(self, header_name, header_value):\n        self.default_headers[header_name] = header_value\n\n    _default = None\n\n    @classmethod\n    def get_default(cls):\n        \"\"\"Return new instance of ApiClient.\n\n        This method returns newly created, based on default constructor,\n        object of ApiClient class or returns a copy of default\n        ApiClient.\n\n        :return: The ApiClient object.\n        \"\"\"\n        if cls._default is None:\n            cls._default = ApiClient()\n        return cls._default\n\n    @classmethod\n    def set_default(cls, default):\n        \"\"\"Set default instance of ApiClient.\n\n        It stores default ApiClient.\n\n        :param default: object of ApiClient.\n        \"\"\"\n        cls._default = default\n\n    def param_serialize(\n        self,\n        method,\n        resource_path,\n        path_params=None,\n        query_params=None,\n        header_params=None,\n        body=None,\n        post_params=None,\n        files=None,\n        auth_settings=None,\n        collection_formats=None,\n        _host=None,\n        _request_auth=None,\n    ) -&gt; RequestSerialized:\n        \"\"\"Builds the HTTP request params needed by the request.\n        :param method: Method to call.\n        :param resource_path: Path to method endpoint.\n        :param path_params: Path parameters in the url.\n        :param query_params: Query parameters in the url.\n        :param header_params: Header parameters to be\n            placed in the request header.\n        :param body: Request body.\n        :param post_params dict: Request post form parameters,\n            for `application/x-www-form-urlencoded`, `multipart/form-data`.\n        :param auth_settings list: Auth Settings names for the request.\n        :param files dict: key -&gt; filename, value -&gt; filepath,\n            for `multipart/form-data`.\n        :param collection_formats: dict of collection formats for path, query,\n            header, and post parameters.\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the authentication\n                              in the spec for a single request.\n        :return: tuple of form (path, http_method, query_params, header_params,\n            body, post_params, files)\n        \"\"\"\n\n        config = self.configuration\n\n        # header parameters\n        header_params = header_params or {}\n        header_params.update(self.default_headers)\n        if self.cookie:\n            header_params[\"Cookie\"] = self.cookie\n        if header_params:\n            header_params = self.sanitize_for_serialization(header_params)\n            header_params = dict(\n                self.parameters_to_tuples(header_params, collection_formats)\n            )\n\n        # path parameters\n        if path_params:\n            path_params = self.sanitize_for_serialization(path_params)\n            path_params = self.parameters_to_tuples(path_params, collection_formats)\n            for k, v in path_params:\n                # specified safe chars, encode everything\n                resource_path = resource_path.replace(\n                    f\"{{{k}}}\", quote(str(v), safe=config.safe_chars_for_path_param)\n                )\n\n        # post parameters\n        if post_params or files:\n            post_params = post_params if post_params else []\n            post_params = self.sanitize_for_serialization(post_params)\n            post_params = self.parameters_to_tuples(post_params, collection_formats)\n            if files:\n                post_params.extend(self.files_parameters(files))\n\n        # auth setting\n        self.update_params_for_auth(\n            header_params,\n            query_params,\n            auth_settings,\n            resource_path,\n            method,\n            body,\n            request_auth=_request_auth,\n        )\n\n        # body\n        if body:\n            body = self.sanitize_for_serialization(body)\n\n        # request url\n        if _host is None or self.configuration.ignore_operation_servers:\n            url = self.configuration.host + resource_path\n        else:\n            # use server/host defined in path or operation instead\n            url = _host + resource_path\n\n        # query parameters\n        if query_params:\n            query_params = self.sanitize_for_serialization(query_params)\n            url_query = self.parameters_to_url_query(query_params, collection_formats)\n            url += \"?\" + url_query\n\n        return method, url, header_params, body, post_params\n\n    def call_api(\n        self,\n        method,\n        url,\n        header_params=None,\n        body=None,\n        post_params=None,\n        _request_timeout=None,\n    ) -&gt; rest.RESTResponse:\n        \"\"\"Makes the HTTP request (synchronous)\n        :param method: Method to call.\n        :param url: Path to method endpoint.\n        :param header_params: Header parameters to be\n            placed in the request header.\n        :param body: Request body.\n        :param post_params dict: Request post form parameters,\n            for `application/x-www-form-urlencoded`, `multipart/form-data`.\n        :param _request_timeout: timeout setting for this request.\n        :return: RESTResponse\n        \"\"\"\n\n        try:\n            # perform request and return response\n            response_data = self.rest_client.request(\n                method,\n                url,\n                headers=header_params,\n                body=body,\n                post_params=post_params,\n                _request_timeout=_request_timeout,\n            )\n\n        except ApiException as e:\n            raise e\n\n        return response_data\n\n    def response_deserialize(\n        self,\n        response_data: rest.RESTResponse,\n        response_types_map: dict[str, ApiResponseT] | None = None,\n    ) -&gt; ApiResponse[ApiResponseT]:\n        \"\"\"Deserializes response into an object.\n        :param response_data: RESTResponse object to be deserialized.\n        :param response_types_map: dict of response types.\n        :return: ApiResponse\n        \"\"\"\n\n        msg = \"RESTResponse.read() must be called before passing it to response_deserialize()\"\n        assert response_data.data is not None, msg\n\n        response_type = response_types_map.get(str(response_data.status), None)\n        if (\n            not response_type\n            and isinstance(response_data.status, int)\n            and 100 &lt;= response_data.status &lt;= 599\n        ):\n            # if not found, look for '1XX', '2XX', etc.\n            response_type = response_types_map.get(\n                str(response_data.status)[0] + \"XX\", None\n            )\n\n        # deserialize response data\n        response_text = None\n        return_data = None\n        try:\n            if response_type == \"bytearray\":\n                return_data = response_data.data\n            elif response_type == \"file\":\n                return_data = self.__deserialize_file(response_data)\n            elif response_type is not None:\n                match = None\n                content_type = response_data.getheader(\"content-type\")\n                if content_type is not None:\n                    match = re.search(r\"charset=([a-zA-Z\\-\\d]+)[\\s;]?\", content_type)\n                encoding = match.group(1) if match else \"utf-8\"\n                response_text = response_data.data.decode(encoding)\n                return_data = self.deserialize(\n                    response_text, response_type, content_type\n                )\n        finally:\n            if not 200 &lt;= response_data.status &lt;= 299:\n                raise ApiException.from_response(\n                    http_resp=response_data,\n                    body=response_text,\n                    data=return_data,\n                )\n\n        return ApiResponse(\n            status_code=response_data.status,\n            data=return_data,\n            headers=response_data.getheaders(),\n            raw_data=response_data.data,\n        )\n\n    def sanitize_for_serialization(self, obj):\n        \"\"\"Builds a JSON POST object.\n\n        If obj is None, return None.\n        If obj is SecretStr, return obj.get_secret_value()\n        If obj is str, int, long, float, bool, return directly.\n        If obj is datetime.datetime, datetime.date\n            convert to string in iso8601 format.\n        If obj is decimal.Decimal return string representation.\n        If obj is list, sanitize each element in the list.\n        If obj is dict, return the dict.\n        If obj is OpenAPI model, return the properties dict.\n\n        :param obj: The data to serialize.\n        :return: The serialized form of data.\n        \"\"\"\n        if obj is None:\n            return None\n        elif isinstance(obj, Enum):\n            return obj.value\n        elif isinstance(obj, SecretStr):\n            return obj.get_secret_value()\n        elif isinstance(obj, self.PRIMITIVE_TYPES):\n            return obj\n        elif isinstance(obj, list):\n            return [self.sanitize_for_serialization(sub_obj) for sub_obj in obj]\n        elif isinstance(obj, tuple):\n            return tuple(self.sanitize_for_serialization(sub_obj) for sub_obj in obj)\n        elif isinstance(obj, datetime.datetime | datetime.date):\n            return obj.isoformat()\n        elif isinstance(obj, decimal.Decimal):\n            return str(obj)\n\n        elif isinstance(obj, dict):\n            obj_dict = obj\n        else:\n            # Convert model obj to dict except\n            # attributes `openapi_types`, `attribute_map`\n            # and attributes which value is not None.\n            # Convert attribute name to json key in\n            # model definition for request.\n            if hasattr(obj, \"to_dict\") and callable(obj.to_dict):\n                obj_dict = obj.to_dict()\n            else:\n                obj_dict = obj.__dict__\n\n        return {\n            key: self.sanitize_for_serialization(val) for key, val in obj_dict.items()\n        }\n\n    def deserialize(\n        self, response_text: str, response_type: str, content_type: str | None\n    ):\n        \"\"\"Deserializes response into an object.\n\n        :param response: RESTResponse object to be deserialized.\n        :param response_type: class literal for\n            deserialized object, or string of class name.\n        :param content_type: content type of response.\n\n        :return: deserialized object.\n        \"\"\"\n\n        # fetch data from response object\n        if content_type is None:\n            try:\n                data = json.loads(response_text)\n            except ValueError:\n                data = response_text\n        elif re.match(\n            r\"^application/(json|[\\w!#$&amp;.+-^_]+\\+json)\\s*(;|$)\",\n            content_type,\n            re.IGNORECASE,\n        ):\n            if response_text == \"\":\n                data = \"\"\n            else:\n                data = json.loads(response_text)\n        elif re.match(r\"^text/plain\\s*(;|$)\", content_type, re.IGNORECASE):\n            data = response_text\n        else:\n            raise ApiException(\n                status=0, reason=f\"Unsupported content type: {content_type}\"\n            )\n\n        return self.__deserialize(data, response_type)\n\n    def __deserialize(self, data, klass):\n        \"\"\"Deserializes dict, list, str into an object.\n\n        :param data: dict, list or str.\n        :param klass: class literal, or string of class name.\n\n        :return: object.\n        \"\"\"\n        if data is None:\n            return None\n\n        if isinstance(klass, str):\n            if klass.startswith(\"List[\"):\n                m = re.match(r\"List\\[(.*)]\", klass)\n                assert m is not None, \"Malformed List type definition\"\n                sub_kls = m.group(1)\n                return [self.__deserialize(sub_data, sub_kls) for sub_data in data]\n\n            if klass.startswith(\"Dict[\"):\n                m = re.match(r\"Dict\\[([^,]*), (.*)]\", klass)\n                assert m is not None, \"Malformed Dict type definition\"\n                sub_kls = m.group(2)\n                return {k: self.__deserialize(v, sub_kls) for k, v in data.items()}\n\n            # convert str to class\n            if klass in self.NATIVE_TYPES_MAPPING:\n                klass = self.NATIVE_TYPES_MAPPING[klass]\n            else:\n                klass = getattr(openapi_client.models, klass)\n\n        if klass in self.PRIMITIVE_TYPES:\n            return self.__deserialize_primitive(data, klass)\n        elif klass == object:\n            return self.__deserialize_object(data)\n        elif klass == datetime.date:\n            return self.__deserialize_date(data)\n        elif klass == datetime.datetime:\n            return self.__deserialize_datetime(data)\n        elif klass == decimal.Decimal:\n            return decimal.Decimal(data)\n        elif issubclass(klass, Enum):\n            return self.__deserialize_enum(data, klass)\n        else:\n            return self.__deserialize_model(data, klass)\n\n    def parameters_to_tuples(self, params, collection_formats):\n        \"\"\"Get parameters as list of tuples, formatting collections.\n\n        :param params: Parameters as dict or list of two-tuples\n        :param dict collection_formats: Parameter collection formats\n        :return: Parameters as list of tuples, collections formatted\n        \"\"\"\n        new_params: list[tuple[str, str]] = []\n        if collection_formats is None:\n            collection_formats = {}\n        for k, v in params.items() if isinstance(params, dict) else params:\n            if k in collection_formats:\n                collection_format = collection_formats[k]\n                if collection_format == \"multi\":\n                    new_params.extend((k, value) for value in v)\n                else:\n                    if collection_format == \"ssv\":\n                        delimiter = \" \"\n                    elif collection_format == \"tsv\":\n                        delimiter = \"\\t\"\n                    elif collection_format == \"pipes\":\n                        delimiter = \"|\"\n                    else:  # csv is the default\n                        delimiter = \",\"\n                    new_params.append((k, delimiter.join(str(value) for value in v)))\n            else:\n                new_params.append((k, v))\n        return new_params\n\n    def parameters_to_url_query(self, params, collection_formats):\n        \"\"\"Get parameters as list of tuples, formatting collections.\n\n        :param params: Parameters as dict or list of two-tuples\n        :param dict collection_formats: Parameter collection formats\n        :return: URL query string (e.g. a=Hello%20World&amp;b=123)\n        \"\"\"\n        new_params: list[tuple[str, str]] = []\n        if collection_formats is None:\n            collection_formats = {}\n        for k, v in params.items() if isinstance(params, dict) else params:\n            if isinstance(v, bool):\n                v = str(v).lower()\n            if isinstance(v, int | float):\n                v = str(v)\n            if isinstance(v, dict):\n                v = json.dumps(v)\n\n            if k in collection_formats:\n                collection_format = collection_formats[k]\n                if collection_format == \"multi\":\n                    new_params.extend((k, str(value)) for value in v)\n                else:\n                    if collection_format == \"ssv\":\n                        delimiter = \" \"\n                    elif collection_format == \"tsv\":\n                        delimiter = \"\\t\"\n                    elif collection_format == \"pipes\":\n                        delimiter = \"|\"\n                    else:  # csv is the default\n                        delimiter = \",\"\n                    new_params.append((\n                        k,\n                        delimiter.join(quote(str(value)) for value in v),\n                    ))\n            else:\n                new_params.append((k, quote(str(v))))\n\n        return \"&amp;\".join([\"=\".join(map(str, item)) for item in new_params])\n\n    def files_parameters(\n        self,\n        files: dict[str, str | bytes | list[str] | list[bytes] | tuple[str, bytes]],\n    ):\n        \"\"\"Builds form parameters.\n\n        :param files: File parameters.\n        :return: Form parameters with files.\n        \"\"\"\n        params = []\n        for k, v in files.items():\n            if isinstance(v, str):\n                with open(v, \"rb\") as f:\n                    filename = os.path.basename(f.name)\n                    filedata = f.read()\n            elif isinstance(v, bytes):\n                filename = k\n                filedata = v\n            elif isinstance(v, tuple):\n                filename, filedata = v\n            elif isinstance(v, list):\n                for file_param in v:\n                    params.extend(self.files_parameters({k: file_param}))\n                continue\n            else:\n                raise ValueError(\"Unsupported file value\")\n            mimetype = mimetypes.guess_type(filename)[0] or \"application/octet-stream\"\n            params.append((k, (filename, filedata, mimetype)))\n        return params\n\n    def select_header_accept(self, accepts: list[str]) -&gt; str | None:\n        \"\"\"Returns `Accept` based on an array of accepts provided.\n\n        :param accepts: List of headers.\n        :return: Accept (e.g. application/json).\n        \"\"\"\n        if not accepts:\n            return None\n\n        for accept in accepts:\n            if re.search(\"json\", accept, re.IGNORECASE):\n                return accept\n\n        return accepts[0]\n\n    def select_header_content_type(self, content_types):\n        \"\"\"Returns `Content-Type` based on an array of content_types provided.\n\n        :param content_types: List of content-types.\n        :return: Content-Type (e.g. application/json).\n        \"\"\"\n        if not content_types:\n            return None\n\n        for content_type in content_types:\n            if re.search(\"json\", content_type, re.IGNORECASE):\n                return content_type\n\n        return content_types[0]\n\n    def update_params_for_auth(\n        self,\n        headers,\n        queries,\n        auth_settings,\n        resource_path,\n        method,\n        body,\n        request_auth=None,\n    ) -&gt; None:\n        \"\"\"Updates header and query params based on authentication setting.\n\n        :param headers: Header parameters dict to be updated.\n        :param queries: Query parameters tuple list to be updated.\n        :param auth_settings: Authentication setting identifiers list.\n        :resource_path: A string representation of the HTTP request resource path.\n        :method: A string representation of the HTTP request method.\n        :body: A object representing the body of the HTTP request.\n        The object type is the return value of sanitize_for_serialization().\n        :param request_auth: if set, the provided settings will\n                             override the token in the configuration.\n        \"\"\"\n        if not auth_settings:\n            return\n\n        if request_auth:\n            self._apply_auth_params(\n                headers, queries, resource_path, method, body, request_auth\n            )\n        else:\n            for auth in auth_settings:\n                auth_setting = self.configuration.auth_settings().get(auth)\n                if auth_setting:\n                    self._apply_auth_params(\n                        headers, queries, resource_path, method, body, auth_setting\n                    )\n\n    def _apply_auth_params(\n        self, headers, queries, resource_path, method, body, auth_setting\n    ) -&gt; None:\n        \"\"\"Updates the request parameters based on a single auth_setting\n\n        :param headers: Header parameters dict to be updated.\n        :param queries: Query parameters tuple list to be updated.\n        :resource_path: A string representation of the HTTP request resource path.\n        :method: A string representation of the HTTP request method.\n        :body: A object representing the body of the HTTP request.\n        The object type is the return value of sanitize_for_serialization().\n        :param auth_setting: auth settings for the endpoint\n        \"\"\"\n        if auth_setting[\"in\"] == \"cookie\":\n            headers[\"Cookie\"] = auth_setting[\"value\"]\n        elif auth_setting[\"in\"] == \"header\":\n            if auth_setting[\"type\"] != \"http-signature\":\n                headers[auth_setting[\"key\"]] = auth_setting[\"value\"]\n        elif auth_setting[\"in\"] == \"query\":\n            queries.append((auth_setting[\"key\"], auth_setting[\"value\"]))\n        else:\n            raise ApiValueError(\"Authentication token must be in `query` or `header`\")\n\n    def __deserialize_file(self, response):\n        \"\"\"Deserializes body to file\n\n        Saves response body into a file in a temporary folder,\n        using the filename from the `Content-Disposition` header if provided.\n\n        handle file downloading\n        save response body into a tmp file and return the instance\n\n        :param response:  RESTResponse.\n        :return: file path.\n        \"\"\"\n        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)\n        os.close(fd)\n        os.remove(path)\n\n        content_disposition = response.getheader(\"Content-Disposition\")\n        if content_disposition:\n            m = re.search(r'filename=[\\'\"]?([^\\'\"\\s]+)[\\'\"]?', content_disposition)\n            assert m is not None, \"Unexpected 'content-disposition' header value\"\n            filename = m.group(1)\n            path = os.path.join(os.path.dirname(path), filename)\n\n        with open(path, \"wb\") as f:\n            f.write(response.data)\n\n        return path\n\n    def __deserialize_primitive(self, data, klass):\n        \"\"\"Deserializes string to primitive type.\n\n        :param data: str.\n        :param klass: class literal.\n\n        :return: int, long, float, str, bool.\n        \"\"\"\n        try:\n            return klass(data)\n        except UnicodeEncodeError:\n            return str(data)\n        except TypeError:\n            return data\n\n    def __deserialize_object(self, value):\n        \"\"\"Return an original value.\n\n        :return: object.\n        \"\"\"\n        return value\n\n    def __deserialize_date(self, string):\n        \"\"\"Deserializes string to date.\n\n        :param string: str.\n        :return: date.\n        \"\"\"\n        try:\n            return parse(string).date()\n        except ImportError:\n            return string\n        except ValueError:\n            raise rest.ApiException(\n                status=0, reason=f\"Failed to parse `{string}` as date object\"\n            )\n\n    def __deserialize_datetime(self, string):\n        \"\"\"Deserializes string to datetime.\n\n        The string should be in iso8601 datetime format.\n\n        :param string: str.\n        :return: datetime.\n        \"\"\"\n        try:\n            return parse(string)\n        except ImportError:\n            return string\n        except ValueError:\n            raise rest.ApiException(\n                status=0,\n                reason=(f\"Failed to parse `{string}` as datetime object\"),\n            )\n\n    def __deserialize_enum(self, data, klass):\n        \"\"\"Deserializes primitive type to enum.\n\n        :param data: primitive type.\n        :param klass: class literal.\n        :return: enum value.\n        \"\"\"\n        try:\n            return klass(data)\n        except ValueError:\n            raise rest.ApiException(\n                status=0, reason=(f\"Failed to parse `{data}` as `{klass}`\")\n            )\n\n    def __deserialize_model(self, data, klass):\n        \"\"\"Deserializes list or dict to model.\n\n        :param data: dict, list.\n        :param klass: class literal.\n        :return: model object.\n        \"\"\"\n\n        return klass.from_dict(data)\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.user_agent","title":"user_agent  <code>property</code> <code>writable</code>","text":"<pre><code>user_agent\n</code></pre> <p>User agent for this API client</p>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.get_default","title":"get_default  <code>classmethod</code>","text":"<pre><code>get_default()\n</code></pre> <p>Return new instance of ApiClient.</p> <p>This method returns newly created, based on default constructor, object of ApiClient class or returns a copy of default ApiClient.</p> <p>:return: The ApiClient object.</p> Source code in <code>src/openapi_client/api_client.py</code> <pre><code>@classmethod\ndef get_default(cls):\n    \"\"\"Return new instance of ApiClient.\n\n    This method returns newly created, based on default constructor,\n    object of ApiClient class or returns a copy of default\n    ApiClient.\n\n    :return: The ApiClient object.\n    \"\"\"\n    if cls._default is None:\n        cls._default = ApiClient()\n    return cls._default\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.set_default","title":"set_default  <code>classmethod</code>","text":"<pre><code>set_default(default)\n</code></pre> <p>Set default instance of ApiClient.</p> <p>It stores default ApiClient.</p> <p>:param default: object of ApiClient.</p> Source code in <code>src/openapi_client/api_client.py</code> <pre><code>@classmethod\ndef set_default(cls, default):\n    \"\"\"Set default instance of ApiClient.\n\n    It stores default ApiClient.\n\n    :param default: object of ApiClient.\n    \"\"\"\n    cls._default = default\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.param_serialize","title":"param_serialize","text":"<pre><code>param_serialize(\n    method,\n    resource_path,\n    path_params=None,\n    query_params=None,\n    header_params=None,\n    body=None,\n    post_params=None,\n    files=None,\n    auth_settings=None,\n    collection_formats=None,\n    _host=None,\n    _request_auth=None,\n) -&gt; RequestSerialized\n</code></pre> <p>Builds the HTTP request params needed by the request. :param method: Method to call. :param resource_path: Path to method endpoint. :param path_params: Path parameters in the url. :param query_params: Query parameters in the url. :param header_params: Header parameters to be     placed in the request header. :param body: Request body. :param post_params dict: Request post form parameters,     for <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>. :param auth_settings list: Auth Settings names for the request. :param files dict: key -&gt; filename, value -&gt; filepath,     for <code>multipart/form-data</code>. :param collection_formats: dict of collection formats for path, query,     header, and post parameters. :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the authentication                       in the spec for a single request. :return: tuple of form (path, http_method, query_params, header_params,     body, post_params, files)</p> Source code in <code>src/openapi_client/api_client.py</code> <pre><code>def param_serialize(\n    self,\n    method,\n    resource_path,\n    path_params=None,\n    query_params=None,\n    header_params=None,\n    body=None,\n    post_params=None,\n    files=None,\n    auth_settings=None,\n    collection_formats=None,\n    _host=None,\n    _request_auth=None,\n) -&gt; RequestSerialized:\n    \"\"\"Builds the HTTP request params needed by the request.\n    :param method: Method to call.\n    :param resource_path: Path to method endpoint.\n    :param path_params: Path parameters in the url.\n    :param query_params: Query parameters in the url.\n    :param header_params: Header parameters to be\n        placed in the request header.\n    :param body: Request body.\n    :param post_params dict: Request post form parameters,\n        for `application/x-www-form-urlencoded`, `multipart/form-data`.\n    :param auth_settings list: Auth Settings names for the request.\n    :param files dict: key -&gt; filename, value -&gt; filepath,\n        for `multipart/form-data`.\n    :param collection_formats: dict of collection formats for path, query,\n        header, and post parameters.\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the authentication\n                          in the spec for a single request.\n    :return: tuple of form (path, http_method, query_params, header_params,\n        body, post_params, files)\n    \"\"\"\n\n    config = self.configuration\n\n    # header parameters\n    header_params = header_params or {}\n    header_params.update(self.default_headers)\n    if self.cookie:\n        header_params[\"Cookie\"] = self.cookie\n    if header_params:\n        header_params = self.sanitize_for_serialization(header_params)\n        header_params = dict(\n            self.parameters_to_tuples(header_params, collection_formats)\n        )\n\n    # path parameters\n    if path_params:\n        path_params = self.sanitize_for_serialization(path_params)\n        path_params = self.parameters_to_tuples(path_params, collection_formats)\n        for k, v in path_params:\n            # specified safe chars, encode everything\n            resource_path = resource_path.replace(\n                f\"{{{k}}}\", quote(str(v), safe=config.safe_chars_for_path_param)\n            )\n\n    # post parameters\n    if post_params or files:\n        post_params = post_params if post_params else []\n        post_params = self.sanitize_for_serialization(post_params)\n        post_params = self.parameters_to_tuples(post_params, collection_formats)\n        if files:\n            post_params.extend(self.files_parameters(files))\n\n    # auth setting\n    self.update_params_for_auth(\n        header_params,\n        query_params,\n        auth_settings,\n        resource_path,\n        method,\n        body,\n        request_auth=_request_auth,\n    )\n\n    # body\n    if body:\n        body = self.sanitize_for_serialization(body)\n\n    # request url\n    if _host is None or self.configuration.ignore_operation_servers:\n        url = self.configuration.host + resource_path\n    else:\n        # use server/host defined in path or operation instead\n        url = _host + resource_path\n\n    # query parameters\n    if query_params:\n        query_params = self.sanitize_for_serialization(query_params)\n        url_query = self.parameters_to_url_query(query_params, collection_formats)\n        url += \"?\" + url_query\n\n    return method, url, header_params, body, post_params\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.call_api","title":"call_api","text":"<pre><code>call_api(\n    method, url, header_params=None, body=None, post_params=None, _request_timeout=None\n) -&gt; RESTResponse\n</code></pre> <p>Makes the HTTP request (synchronous) :param method: Method to call. :param url: Path to method endpoint. :param header_params: Header parameters to be     placed in the request header. :param body: Request body. :param post_params dict: Request post form parameters,     for <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>. :param _request_timeout: timeout setting for this request. :return: RESTResponse</p> Source code in <code>src/openapi_client/api_client.py</code> <pre><code>def call_api(\n    self,\n    method,\n    url,\n    header_params=None,\n    body=None,\n    post_params=None,\n    _request_timeout=None,\n) -&gt; rest.RESTResponse:\n    \"\"\"Makes the HTTP request (synchronous)\n    :param method: Method to call.\n    :param url: Path to method endpoint.\n    :param header_params: Header parameters to be\n        placed in the request header.\n    :param body: Request body.\n    :param post_params dict: Request post form parameters,\n        for `application/x-www-form-urlencoded`, `multipart/form-data`.\n    :param _request_timeout: timeout setting for this request.\n    :return: RESTResponse\n    \"\"\"\n\n    try:\n        # perform request and return response\n        response_data = self.rest_client.request(\n            method,\n            url,\n            headers=header_params,\n            body=body,\n            post_params=post_params,\n            _request_timeout=_request_timeout,\n        )\n\n    except ApiException as e:\n        raise e\n\n    return response_data\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.response_deserialize","title":"response_deserialize","text":"<pre><code>response_deserialize(\n    response_data: RESTResponse, response_types_map: dict[str, T] | None = None\n) -&gt; ApiResponse[T]\n</code></pre> <p>Deserializes response into an object. :param response_data: RESTResponse object to be deserialized. :param response_types_map: dict of response types. :return: ApiResponse</p> Source code in <code>src/openapi_client/api_client.py</code> <pre><code>def response_deserialize(\n    self,\n    response_data: rest.RESTResponse,\n    response_types_map: dict[str, ApiResponseT] | None = None,\n) -&gt; ApiResponse[ApiResponseT]:\n    \"\"\"Deserializes response into an object.\n    :param response_data: RESTResponse object to be deserialized.\n    :param response_types_map: dict of response types.\n    :return: ApiResponse\n    \"\"\"\n\n    msg = \"RESTResponse.read() must be called before passing it to response_deserialize()\"\n    assert response_data.data is not None, msg\n\n    response_type = response_types_map.get(str(response_data.status), None)\n    if (\n        not response_type\n        and isinstance(response_data.status, int)\n        and 100 &lt;= response_data.status &lt;= 599\n    ):\n        # if not found, look for '1XX', '2XX', etc.\n        response_type = response_types_map.get(\n            str(response_data.status)[0] + \"XX\", None\n        )\n\n    # deserialize response data\n    response_text = None\n    return_data = None\n    try:\n        if response_type == \"bytearray\":\n            return_data = response_data.data\n        elif response_type == \"file\":\n            return_data = self.__deserialize_file(response_data)\n        elif response_type is not None:\n            match = None\n            content_type = response_data.getheader(\"content-type\")\n            if content_type is not None:\n                match = re.search(r\"charset=([a-zA-Z\\-\\d]+)[\\s;]?\", content_type)\n            encoding = match.group(1) if match else \"utf-8\"\n            response_text = response_data.data.decode(encoding)\n            return_data = self.deserialize(\n                response_text, response_type, content_type\n            )\n    finally:\n        if not 200 &lt;= response_data.status &lt;= 299:\n            raise ApiException.from_response(\n                http_resp=response_data,\n                body=response_text,\n                data=return_data,\n            )\n\n    return ApiResponse(\n        status_code=response_data.status,\n        data=return_data,\n        headers=response_data.getheaders(),\n        raw_data=response_data.data,\n    )\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.sanitize_for_serialization","title":"sanitize_for_serialization","text":"<pre><code>sanitize_for_serialization(obj)\n</code></pre> <p>Builds a JSON POST object.</p> <p>If obj is None, return None. If obj is SecretStr, return obj.get_secret_value() If obj is str, int, long, float, bool, return directly. If obj is datetime.datetime, datetime.date     convert to string in iso8601 format. If obj is decimal.Decimal return string representation. If obj is list, sanitize each element in the list. If obj is dict, return the dict. If obj is OpenAPI model, return the properties dict.</p> <p>:param obj: The data to serialize. :return: The serialized form of data.</p> Source code in <code>src/openapi_client/api_client.py</code> <pre><code>def sanitize_for_serialization(self, obj):\n    \"\"\"Builds a JSON POST object.\n\n    If obj is None, return None.\n    If obj is SecretStr, return obj.get_secret_value()\n    If obj is str, int, long, float, bool, return directly.\n    If obj is datetime.datetime, datetime.date\n        convert to string in iso8601 format.\n    If obj is decimal.Decimal return string representation.\n    If obj is list, sanitize each element in the list.\n    If obj is dict, return the dict.\n    If obj is OpenAPI model, return the properties dict.\n\n    :param obj: The data to serialize.\n    :return: The serialized form of data.\n    \"\"\"\n    if obj is None:\n        return None\n    elif isinstance(obj, Enum):\n        return obj.value\n    elif isinstance(obj, SecretStr):\n        return obj.get_secret_value()\n    elif isinstance(obj, self.PRIMITIVE_TYPES):\n        return obj\n    elif isinstance(obj, list):\n        return [self.sanitize_for_serialization(sub_obj) for sub_obj in obj]\n    elif isinstance(obj, tuple):\n        return tuple(self.sanitize_for_serialization(sub_obj) for sub_obj in obj)\n    elif isinstance(obj, datetime.datetime | datetime.date):\n        return obj.isoformat()\n    elif isinstance(obj, decimal.Decimal):\n        return str(obj)\n\n    elif isinstance(obj, dict):\n        obj_dict = obj\n    else:\n        # Convert model obj to dict except\n        # attributes `openapi_types`, `attribute_map`\n        # and attributes which value is not None.\n        # Convert attribute name to json key in\n        # model definition for request.\n        if hasattr(obj, \"to_dict\") and callable(obj.to_dict):\n            obj_dict = obj.to_dict()\n        else:\n            obj_dict = obj.__dict__\n\n    return {\n        key: self.sanitize_for_serialization(val) for key, val in obj_dict.items()\n    }\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.deserialize","title":"deserialize","text":"<pre><code>deserialize(response_text: str, response_type: str, content_type: str | None)\n</code></pre> <p>Deserializes response into an object.</p> <p>:param response: RESTResponse object to be deserialized. :param response_type: class literal for     deserialized object, or string of class name. :param content_type: content type of response.</p> <p>:return: deserialized object.</p> Source code in <code>src/openapi_client/api_client.py</code> <pre><code>def deserialize(\n    self, response_text: str, response_type: str, content_type: str | None\n):\n    \"\"\"Deserializes response into an object.\n\n    :param response: RESTResponse object to be deserialized.\n    :param response_type: class literal for\n        deserialized object, or string of class name.\n    :param content_type: content type of response.\n\n    :return: deserialized object.\n    \"\"\"\n\n    # fetch data from response object\n    if content_type is None:\n        try:\n            data = json.loads(response_text)\n        except ValueError:\n            data = response_text\n    elif re.match(\n        r\"^application/(json|[\\w!#$&amp;.+-^_]+\\+json)\\s*(;|$)\",\n        content_type,\n        re.IGNORECASE,\n    ):\n        if response_text == \"\":\n            data = \"\"\n        else:\n            data = json.loads(response_text)\n    elif re.match(r\"^text/plain\\s*(;|$)\", content_type, re.IGNORECASE):\n        data = response_text\n    else:\n        raise ApiException(\n            status=0, reason=f\"Unsupported content type: {content_type}\"\n        )\n\n    return self.__deserialize(data, response_type)\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.parameters_to_tuples","title":"parameters_to_tuples","text":"<pre><code>parameters_to_tuples(params, collection_formats)\n</code></pre> <p>Get parameters as list of tuples, formatting collections.</p> <p>:param params: Parameters as dict or list of two-tuples :param dict collection_formats: Parameter collection formats :return: Parameters as list of tuples, collections formatted</p> Source code in <code>src/openapi_client/api_client.py</code> <pre><code>def parameters_to_tuples(self, params, collection_formats):\n    \"\"\"Get parameters as list of tuples, formatting collections.\n\n    :param params: Parameters as dict or list of two-tuples\n    :param dict collection_formats: Parameter collection formats\n    :return: Parameters as list of tuples, collections formatted\n    \"\"\"\n    new_params: list[tuple[str, str]] = []\n    if collection_formats is None:\n        collection_formats = {}\n    for k, v in params.items() if isinstance(params, dict) else params:\n        if k in collection_formats:\n            collection_format = collection_formats[k]\n            if collection_format == \"multi\":\n                new_params.extend((k, value) for value in v)\n            else:\n                if collection_format == \"ssv\":\n                    delimiter = \" \"\n                elif collection_format == \"tsv\":\n                    delimiter = \"\\t\"\n                elif collection_format == \"pipes\":\n                    delimiter = \"|\"\n                else:  # csv is the default\n                    delimiter = \",\"\n                new_params.append((k, delimiter.join(str(value) for value in v)))\n        else:\n            new_params.append((k, v))\n    return new_params\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.parameters_to_url_query","title":"parameters_to_url_query","text":"<pre><code>parameters_to_url_query(params, collection_formats)\n</code></pre> <p>Get parameters as list of tuples, formatting collections.</p> <p>:param params: Parameters as dict or list of two-tuples :param dict collection_formats: Parameter collection formats :return: URL query string (e.g. a=Hello%20World&amp;b=123)</p> Source code in <code>src/openapi_client/api_client.py</code> <pre><code>def parameters_to_url_query(self, params, collection_formats):\n    \"\"\"Get parameters as list of tuples, formatting collections.\n\n    :param params: Parameters as dict or list of two-tuples\n    :param dict collection_formats: Parameter collection formats\n    :return: URL query string (e.g. a=Hello%20World&amp;b=123)\n    \"\"\"\n    new_params: list[tuple[str, str]] = []\n    if collection_formats is None:\n        collection_formats = {}\n    for k, v in params.items() if isinstance(params, dict) else params:\n        if isinstance(v, bool):\n            v = str(v).lower()\n        if isinstance(v, int | float):\n            v = str(v)\n        if isinstance(v, dict):\n            v = json.dumps(v)\n\n        if k in collection_formats:\n            collection_format = collection_formats[k]\n            if collection_format == \"multi\":\n                new_params.extend((k, str(value)) for value in v)\n            else:\n                if collection_format == \"ssv\":\n                    delimiter = \" \"\n                elif collection_format == \"tsv\":\n                    delimiter = \"\\t\"\n                elif collection_format == \"pipes\":\n                    delimiter = \"|\"\n                else:  # csv is the default\n                    delimiter = \",\"\n                new_params.append((\n                    k,\n                    delimiter.join(quote(str(value)) for value in v),\n                ))\n        else:\n            new_params.append((k, quote(str(v))))\n\n    return \"&amp;\".join([\"=\".join(map(str, item)) for item in new_params])\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.files_parameters","title":"files_parameters","text":"<pre><code>files_parameters(files: dict[str, str | bytes | list[str] | list[bytes] | tuple[str, bytes]])\n</code></pre> <p>Builds form parameters.</p> <p>:param files: File parameters. :return: Form parameters with files.</p> Source code in <code>src/openapi_client/api_client.py</code> <pre><code>def files_parameters(\n    self,\n    files: dict[str, str | bytes | list[str] | list[bytes] | tuple[str, bytes]],\n):\n    \"\"\"Builds form parameters.\n\n    :param files: File parameters.\n    :return: Form parameters with files.\n    \"\"\"\n    params = []\n    for k, v in files.items():\n        if isinstance(v, str):\n            with open(v, \"rb\") as f:\n                filename = os.path.basename(f.name)\n                filedata = f.read()\n        elif isinstance(v, bytes):\n            filename = k\n            filedata = v\n        elif isinstance(v, tuple):\n            filename, filedata = v\n        elif isinstance(v, list):\n            for file_param in v:\n                params.extend(self.files_parameters({k: file_param}))\n            continue\n        else:\n            raise ValueError(\"Unsupported file value\")\n        mimetype = mimetypes.guess_type(filename)[0] or \"application/octet-stream\"\n        params.append((k, (filename, filedata, mimetype)))\n    return params\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.select_header_accept","title":"select_header_accept","text":"<pre><code>select_header_accept(accepts: list[str]) -&gt; str | None\n</code></pre> <p>Returns <code>Accept</code> based on an array of accepts provided.</p> <p>:param accepts: List of headers. :return: Accept (e.g. application/json).</p> Source code in <code>src/openapi_client/api_client.py</code> <pre><code>def select_header_accept(self, accepts: list[str]) -&gt; str | None:\n    \"\"\"Returns `Accept` based on an array of accepts provided.\n\n    :param accepts: List of headers.\n    :return: Accept (e.g. application/json).\n    \"\"\"\n    if not accepts:\n        return None\n\n    for accept in accepts:\n        if re.search(\"json\", accept, re.IGNORECASE):\n            return accept\n\n    return accepts[0]\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.select_header_content_type","title":"select_header_content_type","text":"<pre><code>select_header_content_type(content_types)\n</code></pre> <p>Returns <code>Content-Type</code> based on an array of content_types provided.</p> <p>:param content_types: List of content-types. :return: Content-Type (e.g. application/json).</p> Source code in <code>src/openapi_client/api_client.py</code> <pre><code>def select_header_content_type(self, content_types):\n    \"\"\"Returns `Content-Type` based on an array of content_types provided.\n\n    :param content_types: List of content-types.\n    :return: Content-Type (e.g. application/json).\n    \"\"\"\n    if not content_types:\n        return None\n\n    for content_type in content_types:\n        if re.search(\"json\", content_type, re.IGNORECASE):\n            return content_type\n\n    return content_types[0]\n</code></pre>"},{"location":"reference/openapi_client/api_client/#openapi_client.api_client.ApiClient.update_params_for_auth","title":"update_params_for_auth","text":"<pre><code>update_params_for_auth(\n    headers, queries, auth_settings, resource_path, method, body, request_auth=None\n) -&gt; None\n</code></pre> <p>Updates header and query params based on authentication setting.</p> <p>:param headers: Header parameters dict to be updated. :param queries: Query parameters tuple list to be updated. :param auth_settings: Authentication setting identifiers list. :resource_path: A string representation of the HTTP request resource path. :method: A string representation of the HTTP request method. :body: A object representing the body of the HTTP request. The object type is the return value of sanitize_for_serialization(). :param request_auth: if set, the provided settings will                      override the token in the configuration.</p> Source code in <code>src/openapi_client/api_client.py</code> <pre><code>def update_params_for_auth(\n    self,\n    headers,\n    queries,\n    auth_settings,\n    resource_path,\n    method,\n    body,\n    request_auth=None,\n) -&gt; None:\n    \"\"\"Updates header and query params based on authentication setting.\n\n    :param headers: Header parameters dict to be updated.\n    :param queries: Query parameters tuple list to be updated.\n    :param auth_settings: Authentication setting identifiers list.\n    :resource_path: A string representation of the HTTP request resource path.\n    :method: A string representation of the HTTP request method.\n    :body: A object representing the body of the HTTP request.\n    The object type is the return value of sanitize_for_serialization().\n    :param request_auth: if set, the provided settings will\n                         override the token in the configuration.\n    \"\"\"\n    if not auth_settings:\n        return\n\n    if request_auth:\n        self._apply_auth_params(\n            headers, queries, resource_path, method, body, request_auth\n        )\n    else:\n        for auth in auth_settings:\n            auth_setting = self.configuration.auth_settings().get(auth)\n            if auth_setting:\n                self._apply_auth_params(\n                    headers, queries, resource_path, method, body, auth_setting\n                )\n</code></pre>"},{"location":"reference/openapi_client/api_response/","title":"api_response","text":"<p>API response object.</p>"},{"location":"reference/openapi_client/api_response/#openapi_client.api_response.ApiResponse","title":"ApiResponse","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p> <p>API response object</p> Source code in <code>src/openapi_client/api_response.py</code> <pre><code>class ApiResponse(BaseModel, Generic[T]):\n    \"\"\"\n    API response object\n    \"\"\"\n\n    status_code: StrictInt = Field(description=\"HTTP status code\")\n    headers: Mapping[str, str] | None = Field(None, description=\"HTTP headers\")\n    data: T = Field(description=\"Deserialized data given the data type\")\n    raw_data: StrictBytes = Field(description=\"Raw data (HTTP response body)\")\n\n    model_config = {\"arbitrary_types_allowed\": True}\n</code></pre>"},{"location":"reference/openapi_client/configuration/","title":"configuration","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration","title":"Configuration","text":"<p>This class contains various settings of the API client.</p> <p>:param host: Base url. :param ignore_operation_servers   Boolean to ignore operation servers for the API client.   Config will use <code>host</code> as the base url regardless of the operation servers. :param api_key: Dict to store API key(s).   Each entry in the dict specifies an API key.   The dict key is the name of the security scheme in the OAS specification.   The dict value is the API key secret. :param api_key_prefix: Dict to store API prefix (e.g. Bearer).   The dict key is the name of the security scheme in the OAS specification.   The dict value is an API key prefix when generating the auth data. :param username: Username for HTTP basic authentication. :param password: Password for HTTP basic authentication. :param access_token: Access token. :param server_index: Index to servers configuration. :param server_variables: Mapping with string values to replace variables in   templated server configuration. The validation of enums is performed for   variables with defined enum values before. :param server_operation_index: Mapping from operation ID to an index to server   configuration. :param server_operation_variables: Mapping from operation ID to a mapping with   string values to replace variables in templated server configuration.   The validation of enums is performed for variables with defined enum   values before. :param ssl_ca_cert: str - the path to a file of concatenated CA certificates   in PEM format. :param retries: Number of retries for API requests.</p> Source code in <code>src/openapi_client/configuration.py</code> <pre><code>class Configuration:\n    \"\"\"This class contains various settings of the API client.\n\n    :param host: Base url.\n    :param ignore_operation_servers\n      Boolean to ignore operation servers for the API client.\n      Config will use `host` as the base url regardless of the operation servers.\n    :param api_key: Dict to store API key(s).\n      Each entry in the dict specifies an API key.\n      The dict key is the name of the security scheme in the OAS specification.\n      The dict value is the API key secret.\n    :param api_key_prefix: Dict to store API prefix (e.g. Bearer).\n      The dict key is the name of the security scheme in the OAS specification.\n      The dict value is an API key prefix when generating the auth data.\n    :param username: Username for HTTP basic authentication.\n    :param password: Password for HTTP basic authentication.\n    :param access_token: Access token.\n    :param server_index: Index to servers configuration.\n    :param server_variables: Mapping with string values to replace variables in\n      templated server configuration. The validation of enums is performed for\n      variables with defined enum values before.\n    :param server_operation_index: Mapping from operation ID to an index to server\n      configuration.\n    :param server_operation_variables: Mapping from operation ID to a mapping with\n      string values to replace variables in templated server configuration.\n      The validation of enums is performed for variables with defined enum\n      values before.\n    :param ssl_ca_cert: str - the path to a file of concatenated CA certificates\n      in PEM format.\n    :param retries: Number of retries for API requests.\n\n    \"\"\"\n\n    _default = None\n\n    def __init__(\n        self,\n        host=None,\n        api_key=None,\n        api_key_prefix=None,\n        username=None,\n        password=None,\n        access_token=None,\n        server_index=None,\n        server_variables=None,\n        server_operation_index=None,\n        server_operation_variables=None,\n        ignore_operation_servers=False,\n        ssl_ca_cert=None,\n        retries=None,\n        *,\n        debug: bool | None = None,\n    ) -&gt; None:\n        \"\"\"Constructor\"\"\"\n        self._base_path = \"http://localhost\" if host is None else host\n        \"\"\"Default Base url\n        \"\"\"\n        self.server_index = 0 if server_index is None and host is None else server_index\n        self.server_operation_index = server_operation_index or {}\n        \"\"\"Default server index\n        \"\"\"\n        self.server_variables = server_variables or {}\n        self.server_operation_variables = server_operation_variables or {}\n        \"\"\"Default server variables\n        \"\"\"\n        self.ignore_operation_servers = ignore_operation_servers\n        \"\"\"Ignore operation servers\n        \"\"\"\n        self.temp_folder_path = None\n        \"\"\"Temp file folder for downloading files\n        \"\"\"\n        # Authentication Settings\n        self.api_key = {}\n        if api_key:\n            self.api_key = api_key\n        \"\"\"dict to store API key(s)\n        \"\"\"\n        self.api_key_prefix = {}\n        if api_key_prefix:\n            self.api_key_prefix = api_key_prefix\n        \"\"\"dict to store API prefix (e.g. Bearer)\n        \"\"\"\n        self.refresh_api_key_hook = None\n        \"\"\"function hook to refresh API key if expired\n        \"\"\"\n        self.username = username\n        \"\"\"Username for HTTP basic authentication\n        \"\"\"\n        self.password = password\n        \"\"\"Password for HTTP basic authentication\n        \"\"\"\n        self.access_token = access_token\n        \"\"\"Access token\n        \"\"\"\n        self.logger = {}\n        \"\"\"Logging Settings\n        \"\"\"\n        self.logger[\"package_logger\"] = logging.getLogger(\"openapi_client\")\n        self.logger[\"urllib3_logger\"] = logging.getLogger(\"urllib3\")\n        self.logger_format = \"%(asctime)s %(levelname)s %(message)s\"\n        \"\"\"Log format\n        \"\"\"\n        self.logger_stream_handler = None\n        \"\"\"Log stream handler\n        \"\"\"\n        self.logger_file_handler: FileHandler | None = None\n        \"\"\"Log file handler\n        \"\"\"\n        self.logger_file = None\n        \"\"\"Debug file location\n        \"\"\"\n        if debug is not None:\n            self.debug = debug\n        else:\n            self.__debug = False\n        \"\"\"Debug switch\n        \"\"\"\n\n        self.verify_ssl = True\n        \"\"\"SSL/TLS verification\n           Set this to false to skip verifying SSL certificate when calling API\n           from https server.\n        \"\"\"\n        self.ssl_ca_cert = ssl_ca_cert\n        \"\"\"Set this to customize the certificate file to verify the peer.\n        \"\"\"\n        self.cert_file = None\n        \"\"\"client certificate file\n        \"\"\"\n        self.key_file = None\n        \"\"\"client key file\n        \"\"\"\n        self.assert_hostname = None\n        \"\"\"Set this to True/False to enable/disable SSL hostname verification.\n        \"\"\"\n        self.tls_server_name = None\n        \"\"\"SSL/TLS Server Name Indication (SNI)\n           Set this to the SNI value expected by the server.\n        \"\"\"\n\n        self.connection_pool_maxsize = multiprocessing.cpu_count() * 5\n        \"\"\"urllib3 connection pool's maximum number of connections saved\n           per pool. urllib3 uses 1 connection as default value, but this is\n           not the best value when you are making a lot of possibly parallel\n           requests to the same host, which is often the case here.\n           cpu_count * 5 is used as default value to increase performance.\n        \"\"\"\n\n        self.proxy: str | None = None\n        \"\"\"Proxy URL\n        \"\"\"\n        self.proxy_headers = None\n        \"\"\"Proxy headers\n        \"\"\"\n        self.safe_chars_for_path_param = \"\"\n        \"\"\"Safe chars for path_param\n        \"\"\"\n        self.retries = retries\n        \"\"\"Adding retries to override urllib3 default value 3\n        \"\"\"\n        # Enable client side validation\n        self.client_side_validation = True\n\n        self.socket_options = None\n        \"\"\"Options to pass down to the underlying urllib3 socket\n        \"\"\"\n\n        self.datetime_format = \"%Y-%m-%dT%H:%M:%S.%f%z\"\n        \"\"\"datetime format\n        \"\"\"\n\n        self.date_format = \"%Y-%m-%d\"\n        \"\"\"date format\n        \"\"\"\n\n    def __deepcopy__(self, memo):\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n        for k, v in self.__dict__.items():\n            if k not in (\"logger\", \"logger_file_handler\"):\n                setattr(result, k, copy.deepcopy(v, memo))\n        # shallow copy of loggers\n        result.logger = copy.copy(self.logger)\n        # use setters to configure loggers\n        result.logger_file = self.logger_file\n        result.debug = self.debug\n        return result\n\n    def __setattr__(self, name, value):\n        object.__setattr__(self, name, value)\n\n    @classmethod\n    def set_default(cls, default):\n        \"\"\"Set default instance of configuration.\n\n        It stores default configuration, which can be\n        returned by get_default_copy method.\n\n        :param default: object of Configuration\n        \"\"\"\n        cls._default = default\n\n    @classmethod\n    def get_default_copy(cls):\n        \"\"\"Deprecated. Please use `get_default` instead.\n\n        Deprecated. Please use `get_default` instead.\n\n        :return: The configuration object.\n        \"\"\"\n        return cls.get_default()\n\n    @classmethod\n    def get_default(cls):\n        \"\"\"Return the default configuration.\n\n        This method returns newly created, based on default constructor,\n        object of Configuration class or returns a copy of default\n        configuration.\n\n        :return: The configuration object.\n        \"\"\"\n        if cls._default is None:\n            cls._default = Configuration()\n        return cls._default\n\n    @property\n    def logger_file(self):\n        \"\"\"The logger file.\n\n        If the logger_file is None, then add stream handler and remove file\n        handler. Otherwise, add file handler and remove stream handler.\n\n        :param value: The logger_file path.\n        :type: str\n        \"\"\"\n        return self.__logger_file\n\n    @logger_file.setter\n    def logger_file(self, value):\n        \"\"\"The logger file.\n\n        If the logger_file is None, then add stream handler and remove file\n        handler. Otherwise, add file handler and remove stream handler.\n\n        :param value: The logger_file path.\n        :type: str\n        \"\"\"\n        self.__logger_file = value\n        if self.__logger_file:\n            # If set logging file,\n            # then add file handler and remove stream handler.\n            self.logger_file_handler = logging.FileHandler(self.__logger_file)\n            self.logger_file_handler.setFormatter(self.logger_formatter)\n            for _, logger in self.logger.items():\n                logger.addHandler(self.logger_file_handler)\n\n    @property\n    def debug(self):\n        \"\"\"Debug status\n\n        :param value: The debug status, True or False.\n        :type: bool\n        \"\"\"\n        return self.__debug\n\n    @debug.setter\n    def debug(self, value):\n        \"\"\"Debug status\n\n        :param value: The debug status, True or False.\n        :type: bool\n        \"\"\"\n        self.__debug = value\n        if self.__debug:\n            # if debug status is True, turn on debug logging\n            for _, logger in self.logger.items():\n                logger.setLevel(logging.DEBUG)\n            # turn on httplib debug\n            httplib.HTTPConnection.debuglevel = 1\n        else:\n            # if debug status is False, turn off debug logging,\n            # setting log level to default `logging.WARNING`\n            for _, logger in self.logger.items():\n                logger.setLevel(logging.WARNING)\n            # turn off httplib debug\n            httplib.HTTPConnection.debuglevel = 0\n\n    @property\n    def logger_format(self):\n        \"\"\"The logger format.\n\n        The logger_formatter will be updated when sets logger_format.\n\n        :param value: The format string.\n        :type: str\n        \"\"\"\n        return self.__logger_format\n\n    @logger_format.setter\n    def logger_format(self, value):\n        \"\"\"The logger format.\n\n        The logger_formatter will be updated when sets logger_format.\n\n        :param value: The format string.\n        :type: str\n        \"\"\"\n        self.__logger_format = value\n        self.logger_formatter = logging.Formatter(self.__logger_format)\n\n    def get_api_key_with_prefix(self, identifier, alias=None):\n        \"\"\"Gets API key (with prefix if set).\n\n        :param identifier: The identifier of apiKey.\n        :param alias: The alternative identifier of apiKey.\n        :return: The token for api key authentication.\n        \"\"\"\n        if self.refresh_api_key_hook is not None:\n            self.refresh_api_key_hook(self)\n        key = self.api_key.get(\n            identifier, self.api_key.get(alias) if alias is not None else None\n        )\n        if key:\n            prefix = self.api_key_prefix.get(identifier)\n            if prefix:\n                return f\"{prefix} {key}\"\n            else:\n                return key\n\n    def get_basic_auth_token(self):\n        \"\"\"Gets HTTP basic authentication header (string).\n\n        :return: The token for basic HTTP authentication.\n        \"\"\"\n        username = \"\"\n        if self.username is not None:\n            username = self.username\n        password = \"\"\n        if self.password is not None:\n            password = self.password\n        return urllib3.util.make_headers(basic_auth=username + \":\" + password).get(\n            \"authorization\"\n        )\n\n    def auth_settings(self):\n        \"\"\"Gets Auth Settings dict for api client.\n\n        :return: The Auth Settings information dict.\n        \"\"\"\n        auth = {}\n        return auth\n\n    def to_debug_report(self):\n        \"\"\"Gets the essential information for debugging.\n\n        :return: The report for debugging.\n        \"\"\"\n        return (\n            \"Python SDK Debug Report:\\n\"\n            f\"OS: {sys.platform}\\n\"\n            f\"Python Version: {sys.version}\\n\"\n            \"Version of the API: 0.1.0\\n\"\n            \"SDK Package Version: 1.0.0\"\n        )\n\n    def get_host_settings(self):\n        \"\"\"Gets an array of host settings\n\n        :return: An array of host settings\n        \"\"\"\n        return [\n            {\n                \"url\": \"\",\n                \"description\": \"No description provided\",\n            }\n        ]\n\n    def get_host_from_settings(self, index, variables=None, servers=None):\n        \"\"\"Gets host URL based on the index and variables\n        :param index: array index of the host settings\n        :param variables: hash of variable and the corresponding value\n        :param servers: an array of host settings or None\n        :return: URL based on host settings\n        \"\"\"\n        if index is None:\n            return self._base_path\n\n        variables = {} if variables is None else variables\n        servers = self.get_host_settings() if servers is None else servers\n\n        try:\n            server = servers[index]\n        except IndexError:\n            raise ValueError(\n                f\"Invalid index {index} when selecting the host settings. \"\n                f\"Must be less than {len(servers)}\"\n            )\n\n        url = server[\"url\"]\n\n        # go through variables and replace placeholders\n        for variable_name, variable in server.get(\"variables\", {}).items():\n            used_value = variables.get(variable_name, variable[\"default_value\"])\n\n            if \"enum_values\" in variable and used_value not in variable[\"enum_values\"]:\n                raise ValueError(\n                    \"The variable `{}` in the host URL has invalid value \"\n                    \"{}. Must be {}.\".format(\n                        variable_name, variables[variable_name], variable[\"enum_values\"]\n                    )\n                )\n\n            url = url.replace(\"{\" + variable_name + \"}\", used_value)\n\n        return url\n\n    @property\n    def host(self):\n        \"\"\"Return generated host.\"\"\"\n        return self.get_host_from_settings(\n            self.server_index, variables=self.server_variables\n        )\n\n    @host.setter\n    def host(self, value):\n        \"\"\"Fix base path.\"\"\"\n        self._base_path = value\n        self.server_index = None\n</code></pre>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.server_operation_index","title":"server_operation_index  <code>instance-attribute</code>","text":"<pre><code>server_operation_index = server_operation_index or {}\n</code></pre> <p>Default server index</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.server_operation_variables","title":"server_operation_variables  <code>instance-attribute</code>","text":"<pre><code>server_operation_variables = server_operation_variables or {}\n</code></pre> <p>Default server variables</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.ignore_operation_servers","title":"ignore_operation_servers  <code>instance-attribute</code>","text":"<pre><code>ignore_operation_servers = ignore_operation_servers\n</code></pre> <p>Ignore operation servers</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.temp_folder_path","title":"temp_folder_path  <code>instance-attribute</code>","text":"<pre><code>temp_folder_path = None\n</code></pre> <p>Temp file folder for downloading files</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.refresh_api_key_hook","title":"refresh_api_key_hook  <code>instance-attribute</code>","text":"<pre><code>refresh_api_key_hook = None\n</code></pre> <p>function hook to refresh API key if expired</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username = username\n</code></pre> <p>Username for HTTP basic authentication</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password = password\n</code></pre> <p>Password for HTTP basic authentication</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.access_token","title":"access_token  <code>instance-attribute</code>","text":"<pre><code>access_token = access_token\n</code></pre> <p>Access token</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = {}\n</code></pre> <p>Logging Settings</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.logger_stream_handler","title":"logger_stream_handler  <code>instance-attribute</code>","text":"<pre><code>logger_stream_handler = None\n</code></pre> <p>Log stream handler</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.logger_file_handler","title":"logger_file_handler  <code>instance-attribute</code>","text":"<pre><code>logger_file_handler: FileHandler | None = None\n</code></pre> <p>Log file handler</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.verify_ssl","title":"verify_ssl  <code>instance-attribute</code>","text":"<pre><code>verify_ssl = True\n</code></pre> <p>SSL/TLS verification Set this to false to skip verifying SSL certificate when calling API from https server.</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.ssl_ca_cert","title":"ssl_ca_cert  <code>instance-attribute</code>","text":"<pre><code>ssl_ca_cert = ssl_ca_cert\n</code></pre> <p>Set this to customize the certificate file to verify the peer.</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.cert_file","title":"cert_file  <code>instance-attribute</code>","text":"<pre><code>cert_file = None\n</code></pre> <p>client certificate file</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.key_file","title":"key_file  <code>instance-attribute</code>","text":"<pre><code>key_file = None\n</code></pre> <p>client key file</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.assert_hostname","title":"assert_hostname  <code>instance-attribute</code>","text":"<pre><code>assert_hostname = None\n</code></pre> <p>Set this to True/False to enable/disable SSL hostname verification.</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.tls_server_name","title":"tls_server_name  <code>instance-attribute</code>","text":"<pre><code>tls_server_name = None\n</code></pre> <p>SSL/TLS Server Name Indication (SNI) Set this to the SNI value expected by the server.</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.connection_pool_maxsize","title":"connection_pool_maxsize  <code>instance-attribute</code>","text":"<pre><code>connection_pool_maxsize = cpu_count() * 5\n</code></pre> <p>urllib3 connection pool's maximum number of connections saved per pool. urllib3 uses 1 connection as default value, but this is not the best value when you are making a lot of possibly parallel requests to the same host, which is often the case here. cpu_count * 5 is used as default value to increase performance.</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.proxy","title":"proxy  <code>instance-attribute</code>","text":"<pre><code>proxy: str | None = None\n</code></pre> <p>Proxy URL</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.proxy_headers","title":"proxy_headers  <code>instance-attribute</code>","text":"<pre><code>proxy_headers = None\n</code></pre> <p>Proxy headers</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.safe_chars_for_path_param","title":"safe_chars_for_path_param  <code>instance-attribute</code>","text":"<pre><code>safe_chars_for_path_param = ''\n</code></pre> <p>Safe chars for path_param</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.retries","title":"retries  <code>instance-attribute</code>","text":"<pre><code>retries = retries\n</code></pre> <p>Adding retries to override urllib3 default value 3</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.socket_options","title":"socket_options  <code>instance-attribute</code>","text":"<pre><code>socket_options = None\n</code></pre> <p>Options to pass down to the underlying urllib3 socket</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.datetime_format","title":"datetime_format  <code>instance-attribute</code>","text":"<pre><code>datetime_format = '%Y-%m-%dT%H:%M:%S.%f%z'\n</code></pre> <p>datetime format</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.date_format","title":"date_format  <code>instance-attribute</code>","text":"<pre><code>date_format = '%Y-%m-%d'\n</code></pre> <p>date format</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.logger_file","title":"logger_file  <code>property</code> <code>writable</code>","text":"<pre><code>logger_file\n</code></pre> <p>The logger file.</p> <p>If the logger_file is None, then add stream handler and remove file handler. Otherwise, add file handler and remove stream handler.</p> <p>:param value: The logger_file path. :type: str</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.debug","title":"debug  <code>property</code> <code>writable</code>","text":"<pre><code>debug\n</code></pre> <p>Debug status</p> <p>:param value: The debug status, True or False. :type: bool</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.logger_format","title":"logger_format  <code>property</code> <code>writable</code>","text":"<pre><code>logger_format\n</code></pre> <p>The logger format.</p> <p>The logger_formatter will be updated when sets logger_format.</p> <p>:param value: The format string. :type: str</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.host","title":"host  <code>property</code> <code>writable</code>","text":"<pre><code>host\n</code></pre> <p>Return generated host.</p>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.set_default","title":"set_default  <code>classmethod</code>","text":"<pre><code>set_default(default)\n</code></pre> <p>Set default instance of configuration.</p> <p>It stores default configuration, which can be returned by get_default_copy method.</p> <p>:param default: object of Configuration</p> Source code in <code>src/openapi_client/configuration.py</code> <pre><code>@classmethod\ndef set_default(cls, default):\n    \"\"\"Set default instance of configuration.\n\n    It stores default configuration, which can be\n    returned by get_default_copy method.\n\n    :param default: object of Configuration\n    \"\"\"\n    cls._default = default\n</code></pre>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.get_default_copy","title":"get_default_copy  <code>classmethod</code>","text":"<pre><code>get_default_copy()\n</code></pre> <p>Deprecated. Please use <code>get_default</code> instead.</p> <p>Deprecated. Please use <code>get_default</code> instead.</p> <p>:return: The configuration object.</p> Source code in <code>src/openapi_client/configuration.py</code> <pre><code>@classmethod\ndef get_default_copy(cls):\n    \"\"\"Deprecated. Please use `get_default` instead.\n\n    Deprecated. Please use `get_default` instead.\n\n    :return: The configuration object.\n    \"\"\"\n    return cls.get_default()\n</code></pre>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.get_default","title":"get_default  <code>classmethod</code>","text":"<pre><code>get_default()\n</code></pre> <p>Return the default configuration.</p> <p>This method returns newly created, based on default constructor, object of Configuration class or returns a copy of default configuration.</p> <p>:return: The configuration object.</p> Source code in <code>src/openapi_client/configuration.py</code> <pre><code>@classmethod\ndef get_default(cls):\n    \"\"\"Return the default configuration.\n\n    This method returns newly created, based on default constructor,\n    object of Configuration class or returns a copy of default\n    configuration.\n\n    :return: The configuration object.\n    \"\"\"\n    if cls._default is None:\n        cls._default = Configuration()\n    return cls._default\n</code></pre>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.get_api_key_with_prefix","title":"get_api_key_with_prefix","text":"<pre><code>get_api_key_with_prefix(identifier, alias=None)\n</code></pre> <p>Gets API key (with prefix if set).</p> <p>:param identifier: The identifier of apiKey. :param alias: The alternative identifier of apiKey. :return: The token for api key authentication.</p> Source code in <code>src/openapi_client/configuration.py</code> <pre><code>def get_api_key_with_prefix(self, identifier, alias=None):\n    \"\"\"Gets API key (with prefix if set).\n\n    :param identifier: The identifier of apiKey.\n    :param alias: The alternative identifier of apiKey.\n    :return: The token for api key authentication.\n    \"\"\"\n    if self.refresh_api_key_hook is not None:\n        self.refresh_api_key_hook(self)\n    key = self.api_key.get(\n        identifier, self.api_key.get(alias) if alias is not None else None\n    )\n    if key:\n        prefix = self.api_key_prefix.get(identifier)\n        if prefix:\n            return f\"{prefix} {key}\"\n        else:\n            return key\n</code></pre>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.get_basic_auth_token","title":"get_basic_auth_token","text":"<pre><code>get_basic_auth_token()\n</code></pre> <p>Gets HTTP basic authentication header (string).</p> <p>:return: The token for basic HTTP authentication.</p> Source code in <code>src/openapi_client/configuration.py</code> <pre><code>def get_basic_auth_token(self):\n    \"\"\"Gets HTTP basic authentication header (string).\n\n    :return: The token for basic HTTP authentication.\n    \"\"\"\n    username = \"\"\n    if self.username is not None:\n        username = self.username\n    password = \"\"\n    if self.password is not None:\n        password = self.password\n    return urllib3.util.make_headers(basic_auth=username + \":\" + password).get(\n        \"authorization\"\n    )\n</code></pre>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.auth_settings","title":"auth_settings","text":"<pre><code>auth_settings()\n</code></pre> <p>Gets Auth Settings dict for api client.</p> <p>:return: The Auth Settings information dict.</p> Source code in <code>src/openapi_client/configuration.py</code> <pre><code>def auth_settings(self):\n    \"\"\"Gets Auth Settings dict for api client.\n\n    :return: The Auth Settings information dict.\n    \"\"\"\n    auth = {}\n    return auth\n</code></pre>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.to_debug_report","title":"to_debug_report","text":"<pre><code>to_debug_report()\n</code></pre> <p>Gets the essential information for debugging.</p> <p>:return: The report for debugging.</p> Source code in <code>src/openapi_client/configuration.py</code> <pre><code>def to_debug_report(self):\n    \"\"\"Gets the essential information for debugging.\n\n    :return: The report for debugging.\n    \"\"\"\n    return (\n        \"Python SDK Debug Report:\\n\"\n        f\"OS: {sys.platform}\\n\"\n        f\"Python Version: {sys.version}\\n\"\n        \"Version of the API: 0.1.0\\n\"\n        \"SDK Package Version: 1.0.0\"\n    )\n</code></pre>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.get_host_settings","title":"get_host_settings","text":"<pre><code>get_host_settings()\n</code></pre> <p>Gets an array of host settings</p> <p>:return: An array of host settings</p> Source code in <code>src/openapi_client/configuration.py</code> <pre><code>def get_host_settings(self):\n    \"\"\"Gets an array of host settings\n\n    :return: An array of host settings\n    \"\"\"\n    return [\n        {\n            \"url\": \"\",\n            \"description\": \"No description provided\",\n        }\n    ]\n</code></pre>"},{"location":"reference/openapi_client/configuration/#openapi_client.configuration.Configuration.get_host_from_settings","title":"get_host_from_settings","text":"<pre><code>get_host_from_settings(index, variables=None, servers=None)\n</code></pre> <p>Gets host URL based on the index and variables :param index: array index of the host settings :param variables: hash of variable and the corresponding value :param servers: an array of host settings or None :return: URL based on host settings</p> Source code in <code>src/openapi_client/configuration.py</code> <pre><code>def get_host_from_settings(self, index, variables=None, servers=None):\n    \"\"\"Gets host URL based on the index and variables\n    :param index: array index of the host settings\n    :param variables: hash of variable and the corresponding value\n    :param servers: an array of host settings or None\n    :return: URL based on host settings\n    \"\"\"\n    if index is None:\n        return self._base_path\n\n    variables = {} if variables is None else variables\n    servers = self.get_host_settings() if servers is None else servers\n\n    try:\n        server = servers[index]\n    except IndexError:\n        raise ValueError(\n            f\"Invalid index {index} when selecting the host settings. \"\n            f\"Must be less than {len(servers)}\"\n        )\n\n    url = server[\"url\"]\n\n    # go through variables and replace placeholders\n    for variable_name, variable in server.get(\"variables\", {}).items():\n        used_value = variables.get(variable_name, variable[\"default_value\"])\n\n        if \"enum_values\" in variable and used_value not in variable[\"enum_values\"]:\n            raise ValueError(\n                \"The variable `{}` in the host URL has invalid value \"\n                \"{}. Must be {}.\".format(\n                    variable_name, variables[variable_name], variable[\"enum_values\"]\n                )\n            )\n\n        url = url.replace(\"{\" + variable_name + \"}\", used_value)\n\n    return url\n</code></pre>"},{"location":"reference/openapi_client/exceptions/","title":"exceptions","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/exceptions/#openapi_client.exceptions.OpenApiException","title":"OpenApiException","text":"<p>               Bases: <code>Exception</code></p> <p>The base exception class for all OpenAPIExceptions</p> Source code in <code>src/openapi_client/exceptions.py</code> <pre><code>class OpenApiException(Exception):\n    \"\"\"The base exception class for all OpenAPIExceptions\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/exceptions/#openapi_client.exceptions.ApiTypeError","title":"ApiTypeError","text":"<p>               Bases: <code>OpenApiException</code>, <code>TypeError</code></p> Source code in <code>src/openapi_client/exceptions.py</code> <pre><code>class ApiTypeError(OpenApiException, TypeError):\n    def __init__(\n        self, msg, path_to_item=None, valid_classes=None, key_type=None\n    ) -&gt; None:\n        \"\"\"Raises an exception for TypeErrors\n\n        Args:\n            msg (str): the exception message\n\n        Keyword Args:\n            path_to_item (list): a list of keys an indices to get to the\n                                 current_item\n                                 None if unset\n            valid_classes (tuple): the primitive classes that current item\n                                   should be an instance of\n                                   None if unset\n            key_type (bool): False if our value is a value in a dict\n                             True if it is a key in a dict\n                             False if our item is an item in a list\n                             None if unset\n        \"\"\"\n        self.path_to_item = path_to_item\n        self.valid_classes = valid_classes\n        self.key_type = key_type\n        full_msg = msg\n        if path_to_item:\n            full_msg = f\"{msg} at {render_path(path_to_item)}\"\n        super().__init__(full_msg)\n</code></pre>"},{"location":"reference/openapi_client/exceptions/#openapi_client.exceptions.ApiValueError","title":"ApiValueError","text":"<p>               Bases: <code>OpenApiException</code>, <code>ValueError</code></p> Source code in <code>src/openapi_client/exceptions.py</code> <pre><code>class ApiValueError(OpenApiException, ValueError):\n    def __init__(self, msg, path_to_item=None) -&gt; None:\n        \"\"\"\n        Args:\n            msg (str): the exception message\n\n        Keyword Args:\n            path_to_item (list) the path to the exception in the\n                received_data dict. None if unset\n        \"\"\"\n\n        self.path_to_item = path_to_item\n        full_msg = msg\n        if path_to_item:\n            full_msg = f\"{msg} at {render_path(path_to_item)}\"\n        super().__init__(full_msg)\n</code></pre>"},{"location":"reference/openapi_client/exceptions/#openapi_client.exceptions.ApiAttributeError","title":"ApiAttributeError","text":"<p>               Bases: <code>OpenApiException</code>, <code>AttributeError</code></p> Source code in <code>src/openapi_client/exceptions.py</code> <pre><code>class ApiAttributeError(OpenApiException, AttributeError):\n    def __init__(self, msg, path_to_item=None) -&gt; None:\n        \"\"\"\n        Raised when an attribute reference or assignment fails.\n\n        Args:\n            msg (str): the exception message\n\n        Keyword Args:\n            path_to_item (None/list) the path to the exception in the\n                received_data dict\n        \"\"\"\n        self.path_to_item = path_to_item\n        full_msg = msg\n        if path_to_item:\n            full_msg = f\"{msg} at {render_path(path_to_item)}\"\n        super().__init__(full_msg)\n</code></pre>"},{"location":"reference/openapi_client/exceptions/#openapi_client.exceptions.ApiKeyError","title":"ApiKeyError","text":"<p>               Bases: <code>OpenApiException</code>, <code>KeyError</code></p> Source code in <code>src/openapi_client/exceptions.py</code> <pre><code>class ApiKeyError(OpenApiException, KeyError):\n    def __init__(self, msg, path_to_item=None) -&gt; None:\n        \"\"\"\n        Args:\n            msg (str): the exception message\n\n        Keyword Args:\n            path_to_item (None/list) the path to the exception in the\n                received_data dict\n        \"\"\"\n        self.path_to_item = path_to_item\n        full_msg = msg\n        if path_to_item:\n            full_msg = f\"{msg} at {render_path(path_to_item)}\"\n        super().__init__(full_msg)\n</code></pre>"},{"location":"reference/openapi_client/exceptions/#openapi_client.exceptions.ApiException","title":"ApiException","text":"<p>               Bases: <code>OpenApiException</code></p> Source code in <code>src/openapi_client/exceptions.py</code> <pre><code>class ApiException(OpenApiException):\n    def __init__(\n        self,\n        status=None,\n        reason=None,\n        http_resp=None,\n        *,\n        body: str | None = None,\n        data: Any | None = None,\n    ) -&gt; None:\n        self.status = status\n        self.reason = reason\n        self.body = body\n        self.data = data\n        self.headers = None\n\n        if http_resp:\n            if self.status is None:\n                self.status = http_resp.status\n            if self.reason is None:\n                self.reason = http_resp.reason\n            if self.body is None:\n                try:\n                    self.body = http_resp.data.decode(\"utf-8\")\n                except Exception:\n                    pass\n            self.headers = http_resp.getheaders()\n\n    @classmethod\n    def from_response(\n        cls,\n        *,\n        http_resp,\n        body: str | None,\n        data: Any | None,\n    ) -&gt; Self:\n        if http_resp.status == 400:\n            raise BadRequestException(http_resp=http_resp, body=body, data=data)\n\n        if http_resp.status == 401:\n            raise UnauthorizedException(http_resp=http_resp, body=body, data=data)\n\n        if http_resp.status == 403:\n            raise ForbiddenException(http_resp=http_resp, body=body, data=data)\n\n        if http_resp.status == 404:\n            raise NotFoundException(http_resp=http_resp, body=body, data=data)\n\n        if 500 &lt;= http_resp.status &lt;= 599:\n            raise ServiceException(http_resp=http_resp, body=body, data=data)\n        raise ApiException(http_resp=http_resp, body=body, data=data)\n\n    def __str__(self):\n        \"\"\"Custom error messages for exception\"\"\"\n        error_message = f\"({self.status})\\n\" f\"Reason: {self.reason}\\n\"\n        if self.headers:\n            error_message += f\"HTTP response headers: {self.headers}\\n\"\n\n        if self.data or self.body:\n            error_message += f\"HTTP response body: {self.data or self.body}\\n\"\n\n        return error_message\n</code></pre>"},{"location":"reference/openapi_client/exceptions/#openapi_client.exceptions.render_path","title":"render_path","text":"<pre><code>render_path(path_to_item)\n</code></pre> <p>Returns a string representation of a path</p> Source code in <code>src/openapi_client/exceptions.py</code> <pre><code>def render_path(path_to_item):\n    \"\"\"Returns a string representation of a path\"\"\"\n    result = \"\"\n    for pth in path_to_item:\n        if isinstance(pth, int):\n            result += f\"[{pth}]\"\n        else:\n            result += f\"['{pth}']\"\n    return result\n</code></pre>"},{"location":"reference/openapi_client/rest/","title":"rest","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/rest/#openapi_client.rest.RESTResponse","title":"RESTResponse","text":"<p>               Bases: <code>IOBase</code></p> Source code in <code>src/openapi_client/rest.py</code> <pre><code>class RESTResponse(io.IOBase):\n    def __init__(self, resp) -&gt; None:\n        self.response = resp\n        self.status = resp.status\n        self.reason = resp.reason\n        self.data = None\n\n    def read(self):\n        if self.data is None:\n            self.data = self.response.data\n        return self.data\n\n    def getheaders(self):\n        \"\"\"Returns a dictionary of the response headers.\"\"\"\n        return self.response.headers\n\n    def getheader(self, name, default=None):\n        \"\"\"Returns a given response header.\"\"\"\n        return self.response.headers.get(name, default)\n</code></pre>"},{"location":"reference/openapi_client/rest/#openapi_client.rest.RESTResponse.getheaders","title":"getheaders","text":"<pre><code>getheaders()\n</code></pre> <p>Returns a dictionary of the response headers.</p> Source code in <code>src/openapi_client/rest.py</code> <pre><code>def getheaders(self):\n    \"\"\"Returns a dictionary of the response headers.\"\"\"\n    return self.response.headers\n</code></pre>"},{"location":"reference/openapi_client/rest/#openapi_client.rest.RESTResponse.getheader","title":"getheader","text":"<pre><code>getheader(name, default=None)\n</code></pre> <p>Returns a given response header.</p> Source code in <code>src/openapi_client/rest.py</code> <pre><code>def getheader(self, name, default=None):\n    \"\"\"Returns a given response header.\"\"\"\n    return self.response.headers.get(name, default)\n</code></pre>"},{"location":"reference/openapi_client/rest/#openapi_client.rest.RESTClientObject","title":"RESTClientObject","text":"Source code in <code>src/openapi_client/rest.py</code> <pre><code>class RESTClientObject:\n    def __init__(self, configuration) -&gt; None:\n        # urllib3.PoolManager will pass all kw parameters to connectionpool\n        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501\n        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501\n        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501\n\n        # cert_reqs\n        if configuration.verify_ssl:\n            cert_reqs = ssl.CERT_REQUIRED\n        else:\n            cert_reqs = ssl.CERT_NONE\n\n        pool_args = {\n            \"cert_reqs\": cert_reqs,\n            \"ca_certs\": configuration.ssl_ca_cert,\n            \"cert_file\": configuration.cert_file,\n            \"key_file\": configuration.key_file,\n        }\n        if configuration.assert_hostname is not None:\n            pool_args[\"assert_hostname\"] = configuration.assert_hostname\n\n        if configuration.retries is not None:\n            pool_args[\"retries\"] = configuration.retries\n\n        if configuration.tls_server_name:\n            pool_args[\"server_hostname\"] = configuration.tls_server_name\n\n        if configuration.socket_options is not None:\n            pool_args[\"socket_options\"] = configuration.socket_options\n\n        if configuration.connection_pool_maxsize is not None:\n            pool_args[\"maxsize\"] = configuration.connection_pool_maxsize\n\n        # https pool manager\n        self.pool_manager: urllib3.PoolManager\n\n        if configuration.proxy:\n            if is_socks_proxy_url(configuration.proxy):\n                from urllib3.contrib.socks import SOCKSProxyManager\n\n                pool_args[\"proxy_url\"] = configuration.proxy\n                pool_args[\"headers\"] = configuration.proxy_headers\n                self.pool_manager = SOCKSProxyManager(**pool_args)\n            else:\n                pool_args[\"proxy_url\"] = configuration.proxy\n                pool_args[\"proxy_headers\"] = configuration.proxy_headers\n                self.pool_manager = urllib3.ProxyManager(**pool_args)\n        else:\n            self.pool_manager = urllib3.PoolManager(**pool_args)\n\n    def request(\n        self,\n        method,\n        url,\n        headers=None,\n        body=None,\n        post_params=None,\n        _request_timeout=None,\n    ):\n        \"\"\"Perform requests.\n\n        :param method: http request method\n        :param url: http request url\n        :param headers: http request headers\n        :param body: request json body, for `application/json`\n        :param post_params: request post parameters,\n                            `application/x-www-form-urlencoded`\n                            and `multipart/form-data`\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        \"\"\"\n        method = method.upper()\n        assert method in [\"GET\", \"HEAD\", \"DELETE\", \"POST\", \"PUT\", \"PATCH\", \"OPTIONS\"]\n\n        if post_params and body:\n            raise ApiValueError(\n                \"body parameter cannot be used with post_params parameter.\"\n            )\n\n        post_params = post_params or {}\n        headers = headers or {}\n\n        timeout = None\n        if _request_timeout:\n            if isinstance(_request_timeout, int | float):\n                timeout = urllib3.Timeout(total=_request_timeout)\n            elif isinstance(_request_timeout, tuple) and len(_request_timeout) == 2:\n                timeout = urllib3.Timeout(\n                    connect=_request_timeout[0], read=_request_timeout[1]\n                )\n\n        try:\n            # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`\n            if method in [\"POST\", \"PUT\", \"PATCH\", \"OPTIONS\", \"DELETE\"]:\n                # no content type provided or payload is json\n                content_type = headers.get(\"Content-Type\")\n                if not content_type or re.search(\"json\", content_type, re.IGNORECASE):\n                    request_body = None\n                    if body is not None:\n                        request_body = json.dumps(body)\n                    r = self.pool_manager.request(\n                        method,\n                        url,\n                        body=request_body,\n                        timeout=timeout,\n                        headers=headers,\n                        preload_content=False,\n                    )\n                elif content_type == \"application/x-www-form-urlencoded\":\n                    r = self.pool_manager.request(\n                        method,\n                        url,\n                        fields=post_params,\n                        encode_multipart=False,\n                        timeout=timeout,\n                        headers=headers,\n                        preload_content=False,\n                    )\n                elif content_type == \"multipart/form-data\":\n                    # must del headers['Content-Type'], or the correct\n                    # Content-Type which generated by urllib3 will be\n                    # overwritten.\n                    del headers[\"Content-Type\"]\n                    # Ensures that dict objects are serialized\n                    post_params = [\n                        (a, json.dumps(b)) if isinstance(b, dict) else (a, b)\n                        for a, b in post_params\n                    ]\n                    r = self.pool_manager.request(\n                        method,\n                        url,\n                        fields=post_params,\n                        encode_multipart=True,\n                        timeout=timeout,\n                        headers=headers,\n                        preload_content=False,\n                    )\n                # Pass a `string` parameter directly in the body to support\n                # other content types than JSON when `body` argument is\n                # provided in serialized form.\n                elif isinstance(body, str) or isinstance(body, bytes):\n                    r = self.pool_manager.request(\n                        method,\n                        url,\n                        body=body,\n                        timeout=timeout,\n                        headers=headers,\n                        preload_content=False,\n                    )\n                elif headers[\"Content-Type\"] == \"text/plain\" and isinstance(body, bool):\n                    request_body = \"true\" if body else \"false\"\n                    r = self.pool_manager.request(\n                        method,\n                        url,\n                        body=request_body,\n                        preload_content=False,\n                        timeout=timeout,\n                        headers=headers,\n                    )\n                else:\n                    # Cannot generate the request from given parameters\n                    msg = \"\"\"Cannot prepare a request message for provided\n                             arguments. Please check that your arguments match\n                             declared content type.\"\"\"\n                    raise ApiException(status=0, reason=msg)\n            # For `GET`, `HEAD`\n            else:\n                r = self.pool_manager.request(\n                    method,\n                    url,\n                    fields={},\n                    timeout=timeout,\n                    headers=headers,\n                    preload_content=False,\n                )\n        except urllib3.exceptions.SSLError as e:\n            msg = \"\\n\".join([type(e).__name__, str(e)])\n            raise ApiException(status=0, reason=msg)\n\n        return RESTResponse(r)\n</code></pre>"},{"location":"reference/openapi_client/rest/#openapi_client.rest.RESTClientObject.request","title":"request","text":"<pre><code>request(method, url, headers=None, body=None, post_params=None, _request_timeout=None)\n</code></pre> <p>Perform requests.</p> <p>:param method: http request method :param url: http request url :param headers: http request headers :param body: request json body, for <code>application/json</code> :param post_params: request post parameters,                     <code>application/x-www-form-urlencoded</code>                     and <code>multipart/form-data</code> :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts.</p> Source code in <code>src/openapi_client/rest.py</code> <pre><code>def request(\n    self,\n    method,\n    url,\n    headers=None,\n    body=None,\n    post_params=None,\n    _request_timeout=None,\n):\n    \"\"\"Perform requests.\n\n    :param method: http request method\n    :param url: http request url\n    :param headers: http request headers\n    :param body: request json body, for `application/json`\n    :param post_params: request post parameters,\n                        `application/x-www-form-urlencoded`\n                        and `multipart/form-data`\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    \"\"\"\n    method = method.upper()\n    assert method in [\"GET\", \"HEAD\", \"DELETE\", \"POST\", \"PUT\", \"PATCH\", \"OPTIONS\"]\n\n    if post_params and body:\n        raise ApiValueError(\n            \"body parameter cannot be used with post_params parameter.\"\n        )\n\n    post_params = post_params or {}\n    headers = headers or {}\n\n    timeout = None\n    if _request_timeout:\n        if isinstance(_request_timeout, int | float):\n            timeout = urllib3.Timeout(total=_request_timeout)\n        elif isinstance(_request_timeout, tuple) and len(_request_timeout) == 2:\n            timeout = urllib3.Timeout(\n                connect=_request_timeout[0], read=_request_timeout[1]\n            )\n\n    try:\n        # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`\n        if method in [\"POST\", \"PUT\", \"PATCH\", \"OPTIONS\", \"DELETE\"]:\n            # no content type provided or payload is json\n            content_type = headers.get(\"Content-Type\")\n            if not content_type or re.search(\"json\", content_type, re.IGNORECASE):\n                request_body = None\n                if body is not None:\n                    request_body = json.dumps(body)\n                r = self.pool_manager.request(\n                    method,\n                    url,\n                    body=request_body,\n                    timeout=timeout,\n                    headers=headers,\n                    preload_content=False,\n                )\n            elif content_type == \"application/x-www-form-urlencoded\":\n                r = self.pool_manager.request(\n                    method,\n                    url,\n                    fields=post_params,\n                    encode_multipart=False,\n                    timeout=timeout,\n                    headers=headers,\n                    preload_content=False,\n                )\n            elif content_type == \"multipart/form-data\":\n                # must del headers['Content-Type'], or the correct\n                # Content-Type which generated by urllib3 will be\n                # overwritten.\n                del headers[\"Content-Type\"]\n                # Ensures that dict objects are serialized\n                post_params = [\n                    (a, json.dumps(b)) if isinstance(b, dict) else (a, b)\n                    for a, b in post_params\n                ]\n                r = self.pool_manager.request(\n                    method,\n                    url,\n                    fields=post_params,\n                    encode_multipart=True,\n                    timeout=timeout,\n                    headers=headers,\n                    preload_content=False,\n                )\n            # Pass a `string` parameter directly in the body to support\n            # other content types than JSON when `body` argument is\n            # provided in serialized form.\n            elif isinstance(body, str) or isinstance(body, bytes):\n                r = self.pool_manager.request(\n                    method,\n                    url,\n                    body=body,\n                    timeout=timeout,\n                    headers=headers,\n                    preload_content=False,\n                )\n            elif headers[\"Content-Type\"] == \"text/plain\" and isinstance(body, bool):\n                request_body = \"true\" if body else \"false\"\n                r = self.pool_manager.request(\n                    method,\n                    url,\n                    body=request_body,\n                    preload_content=False,\n                    timeout=timeout,\n                    headers=headers,\n                )\n            else:\n                # Cannot generate the request from given parameters\n                msg = \"\"\"Cannot prepare a request message for provided\n                         arguments. Please check that your arguments match\n                         declared content type.\"\"\"\n                raise ApiException(status=0, reason=msg)\n        # For `GET`, `HEAD`\n        else:\n            r = self.pool_manager.request(\n                method,\n                url,\n                fields={},\n                timeout=timeout,\n                headers=headers,\n                preload_content=False,\n            )\n    except urllib3.exceptions.SSLError as e:\n        msg = \"\\n\".join([type(e).__name__, str(e)])\n        raise ApiException(status=0, reason=msg)\n\n    return RESTResponse(r)\n</code></pre>"},{"location":"reference/openapi_client/api/","title":"api","text":""},{"location":"reference/openapi_client/api/job_management_api/","title":"job_management_api","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi","title":"JobManagementApi","text":"<p>NOTE: This class is auto generated by OpenAPI Generator Ref: https://openapi-generator.tech</p> <p>Do not edit the class manually.</p> Source code in <code>src/openapi_client/api/job_management_api.py</code> <pre><code>class JobManagementApi:\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n    \"\"\"\n\n    def __init__(self, api_client=None) -&gt; None:\n        if api_client is None:\n            api_client = ApiClient.get_default()\n        self.api_client = api_client\n\n    @validate_call\n    def logs_jobs_uid_logs_get(\n        self,\n        uid: StrictStr,\n        stream: StrictBool | None = None,\n        tail: StrictInt | None = None,\n        namespace: StrictStr | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Logs\n\n\n        :param uid: (required)\n        :type uid: str\n        :param stream:\n        :type stream: bool\n        :param tail:\n        :type tail: int\n        :param namespace:\n        :type namespace: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._logs_jobs_uid_logs_get_serialize(\n            uid=uid,\n            stream=stream,\n            tail=tail,\n            namespace=namespace,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"object\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n    @validate_call\n    def logs_jobs_uid_logs_get_with_http_info(\n        self,\n        uid: StrictStr,\n        stream: StrictBool | None = None,\n        tail: StrictInt | None = None,\n        namespace: StrictStr | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Logs\n\n\n        :param uid: (required)\n        :type uid: str\n        :param stream:\n        :type stream: bool\n        :param tail:\n        :type tail: int\n        :param namespace:\n        :type namespace: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._logs_jobs_uid_logs_get_serialize(\n            uid=uid,\n            stream=stream,\n            tail=tail,\n            namespace=namespace,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"object\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n    @validate_call\n    def logs_jobs_uid_logs_get_without_preload_content(\n        self,\n        uid: StrictStr,\n        stream: StrictBool | None = None,\n        tail: StrictInt | None = None,\n        namespace: StrictStr | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Logs\n\n\n        :param uid: (required)\n        :type uid: str\n        :param stream:\n        :type stream: bool\n        :param tail:\n        :type tail: int\n        :param namespace:\n        :type namespace: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._logs_jobs_uid_logs_get_serialize(\n            uid=uid,\n            stream=stream,\n            tail=tail,\n            namespace=namespace,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"object\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n    def _logs_jobs_uid_logs_get_serialize(\n        self,\n        uid,\n        stream,\n        tail,\n        namespace,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; RequestSerialized:\n        _host = None\n\n        _collection_formats: dict[str, str] = {}\n\n        _path_params: dict[str, str] = {}\n        _query_params: list[tuple[str, str]] = []\n        _header_params: dict[str, str | None] = _headers or {}\n        _form_params: list[tuple[str, str]] = []\n        _files: dict[\n            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]\n        ] = {}\n        _body_params: bytes | None = None\n\n        # process the path parameters\n        if uid is not None:\n            _path_params[\"uid\"] = uid\n        # process the query parameters\n        if stream is not None:\n            _query_params.append((\"stream\", stream))\n\n        if tail is not None:\n            _query_params.append((\"tail\", tail))\n\n        if namespace is not None:\n            _query_params.append((\"namespace\", namespace))\n\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n        # set the HTTP header `Accept`\n        if \"Accept\" not in _header_params:\n            _header_params[\"Accept\"] = self.api_client.select_header_accept([\n                \"application/json\"\n            ])\n\n        # authentication setting\n        _auth_settings: list[str] = []\n\n        return self.api_client.param_serialize(\n            method=\"GET\",\n            resource_path=\"/jobs/{uid}/logs\",\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth,\n        )\n\n    @validate_call\n    def status_jobs_uid_status_get(\n        self,\n        uid: StrictStr,\n        namespace: StrictStr | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Status\n\n\n        :param uid: (required)\n        :type uid: str\n        :param namespace:\n        :type namespace: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._status_jobs_uid_status_get_serialize(\n            uid=uid,\n            namespace=namespace,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"object\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n    @validate_call\n    def status_jobs_uid_status_get_with_http_info(\n        self,\n        uid: StrictStr,\n        namespace: StrictStr | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Status\n\n\n        :param uid: (required)\n        :type uid: str\n        :param namespace:\n        :type namespace: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._status_jobs_uid_status_get_serialize(\n            uid=uid,\n            namespace=namespace,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"object\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n    @validate_call\n    def status_jobs_uid_status_get_without_preload_content(\n        self,\n        uid: StrictStr,\n        namespace: StrictStr | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Status\n\n\n        :param uid: (required)\n        :type uid: str\n        :param namespace:\n        :type namespace: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._status_jobs_uid_status_get_serialize(\n            uid=uid,\n            namespace=namespace,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"object\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n    def _status_jobs_uid_status_get_serialize(\n        self,\n        uid,\n        namespace,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; RequestSerialized:\n        _host = None\n\n        _collection_formats: dict[str, str] = {}\n\n        _path_params: dict[str, str] = {}\n        _query_params: list[tuple[str, str]] = []\n        _header_params: dict[str, str | None] = _headers or {}\n        _form_params: list[tuple[str, str]] = []\n        _files: dict[\n            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]\n        ] = {}\n        _body_params: bytes | None = None\n\n        # process the path parameters\n        if uid is not None:\n            _path_params[\"uid\"] = uid\n        # process the query parameters\n        if namespace is not None:\n            _query_params.append((\"namespace\", namespace))\n\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n        # set the HTTP header `Accept`\n        if \"Accept\" not in _header_params:\n            _header_params[\"Accept\"] = self.api_client.select_header_accept([\n                \"application/json\"\n            ])\n\n        # authentication setting\n        _auth_settings: list[str] = []\n\n        return self.api_client.param_serialize(\n            method=\"GET\",\n            resource_path=\"/jobs/{uid}/status\",\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth,\n        )\n\n    @validate_call\n    def stop_workload_jobs_uid_stop_post(\n        self,\n        uid: StrictStr,\n        namespace: StrictStr | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Stop Workload\n\n\n        :param uid: (required)\n        :type uid: str\n        :param namespace:\n        :type namespace: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._stop_workload_jobs_uid_stop_post_serialize(\n            uid=uid,\n            namespace=namespace,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"object\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n    @validate_call\n    def stop_workload_jobs_uid_stop_post_with_http_info(\n        self,\n        uid: StrictStr,\n        namespace: StrictStr | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Stop Workload\n\n\n        :param uid: (required)\n        :type uid: str\n        :param namespace:\n        :type namespace: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._stop_workload_jobs_uid_stop_post_serialize(\n            uid=uid,\n            namespace=namespace,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"object\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n    @validate_call\n    def stop_workload_jobs_uid_stop_post_without_preload_content(\n        self,\n        uid: StrictStr,\n        namespace: StrictStr | None = None,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Stop Workload\n\n\n        :param uid: (required)\n        :type uid: str\n        :param namespace:\n        :type namespace: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._stop_workload_jobs_uid_stop_post_serialize(\n            uid=uid,\n            namespace=namespace,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"object\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n    def _stop_workload_jobs_uid_stop_post_serialize(\n        self,\n        uid,\n        namespace,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; RequestSerialized:\n        _host = None\n\n        _collection_formats: dict[str, str] = {}\n\n        _path_params: dict[str, str] = {}\n        _query_params: list[tuple[str, str]] = []\n        _header_params: dict[str, str | None] = _headers or {}\n        _form_params: list[tuple[str, str]] = []\n        _files: dict[\n            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]\n        ] = {}\n        _body_params: bytes | None = None\n\n        # process the path parameters\n        if uid is not None:\n            _path_params[\"uid\"] = uid\n        # process the query parameters\n        if namespace is not None:\n            _query_params.append((\"namespace\", namespace))\n\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n        # set the HTTP header `Accept`\n        if \"Accept\" not in _header_params:\n            _header_params[\"Accept\"] = self.api_client.select_header_accept([\n                \"application/json\"\n            ])\n\n        # authentication setting\n        _auth_settings: list[str] = []\n\n        return self.api_client.param_serialize(\n            method=\"POST\",\n            resource_path=\"/jobs/{uid}/stop\",\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth,\n        )\n\n    @validate_call\n    def submit_job_jobs_post(\n        self,\n        create_job_model: CreateJobModel,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; WorkloadIdentifier:\n        \"\"\"Submit Job\n\n\n        :param create_job_model: (required)\n        :type create_job_model: CreateJobModel\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._submit_job_jobs_post_serialize(\n            create_job_model=create_job_model,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"WorkloadIdentifier\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n    @validate_call\n    def submit_job_jobs_post_with_http_info(\n        self,\n        create_job_model: CreateJobModel,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[WorkloadIdentifier]:\n        \"\"\"Submit Job\n\n\n        :param create_job_model: (required)\n        :type create_job_model: CreateJobModel\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._submit_job_jobs_post_serialize(\n            create_job_model=create_job_model,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"WorkloadIdentifier\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n    @validate_call\n    def submit_job_jobs_post_without_preload_content(\n        self,\n        create_job_model: CreateJobModel,\n        _request_timeout: None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[\n            Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n        ] = None,\n        _request_auth: dict[StrictStr, Any] | None = None,\n        _content_type: StrictStr | None = None,\n        _headers: dict[StrictStr, Any] | None = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Submit Job\n\n\n        :param create_job_model: (required)\n        :type create_job_model: CreateJobModel\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\"  # noqa: E501\n\n        _param = self._submit_job_jobs_post_serialize(\n            create_job_model=create_job_model,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index,\n        )\n\n        _response_types_map: dict[str, str | None] = {\n            \"200\": \"WorkloadIdentifier\",\n            \"422\": \"HTTPValidationError\",\n        }\n        response_data = self.api_client.call_api(\n            *_param, _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n    def _submit_job_jobs_post_serialize(\n        self,\n        create_job_model,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; RequestSerialized:\n        _host = None\n\n        _collection_formats: dict[str, str] = {}\n\n        _path_params: dict[str, str] = {}\n        _query_params: list[tuple[str, str]] = []\n        _header_params: dict[str, str | None] = _headers or {}\n        _form_params: list[tuple[str, str]] = []\n        _files: dict[\n            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]\n        ] = {}\n        _body_params: bytes | None = None\n\n        # process the path parameters\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n        if create_job_model is not None:\n            _body_params = create_job_model\n\n        # set the HTTP header `Accept`\n        if \"Accept\" not in _header_params:\n            _header_params[\"Accept\"] = self.api_client.select_header_accept([\n                \"application/json\"\n            ])\n\n        # set the HTTP header `Content-Type`\n        if _content_type:\n            _header_params[\"Content-Type\"] = _content_type\n        else:\n            _default_content_type = self.api_client.select_header_content_type([\n                \"application/json\"\n            ])\n            if _default_content_type is not None:\n                _header_params[\"Content-Type\"] = _default_content_type\n\n        # authentication setting\n        _auth_settings: list[str] = []\n\n        return self.api_client.param_serialize(\n            method=\"POST\",\n            resource_path=\"/jobs\",\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth,\n        )\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.logs_jobs_uid_logs_get","title":"logs_jobs_uid_logs_get","text":"<pre><code>logs_jobs_uid_logs_get(\n    uid: StrictStr,\n    stream: StrictBool | None = None,\n    tail: StrictInt | None = None,\n    namespace: StrictStr | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object\n</code></pre> <p>Logs</p> <p>:param uid: (required) :type uid: str :param stream: :type stream: bool :param tail: :type tail: int :param namespace: :type namespace: str :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef logs_jobs_uid_logs_get(\n    self,\n    uid: StrictStr,\n    stream: StrictBool | None = None,\n    tail: StrictInt | None = None,\n    namespace: StrictStr | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Logs\n\n\n    :param uid: (required)\n    :type uid: str\n    :param stream:\n    :type stream: bool\n    :param tail:\n    :type tail: int\n    :param namespace:\n    :type namespace: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._logs_jobs_uid_logs_get_serialize(\n        uid=uid,\n        stream=stream,\n        tail=tail,\n        namespace=namespace,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"object\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.logs_jobs_uid_logs_get_with_http_info","title":"logs_jobs_uid_logs_get_with_http_info","text":"<pre><code>logs_jobs_uid_logs_get_with_http_info(\n    uid: StrictStr,\n    stream: StrictBool | None = None,\n    tail: StrictInt | None = None,\n    namespace: StrictStr | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]\n</code></pre> <p>Logs</p> <p>:param uid: (required) :type uid: str :param stream: :type stream: bool :param tail: :type tail: int :param namespace: :type namespace: str :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef logs_jobs_uid_logs_get_with_http_info(\n    self,\n    uid: StrictStr,\n    stream: StrictBool | None = None,\n    tail: StrictInt | None = None,\n    namespace: StrictStr | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Logs\n\n\n    :param uid: (required)\n    :type uid: str\n    :param stream:\n    :type stream: bool\n    :param tail:\n    :type tail: int\n    :param namespace:\n    :type namespace: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._logs_jobs_uid_logs_get_serialize(\n        uid=uid,\n        stream=stream,\n        tail=tail,\n        namespace=namespace,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"object\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.logs_jobs_uid_logs_get_without_preload_content","title":"logs_jobs_uid_logs_get_without_preload_content","text":"<pre><code>logs_jobs_uid_logs_get_without_preload_content(\n    uid: StrictStr,\n    stream: StrictBool | None = None,\n    tail: StrictInt | None = None,\n    namespace: StrictStr | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType\n</code></pre> <p>Logs</p> <p>:param uid: (required) :type uid: str :param stream: :type stream: bool :param tail: :type tail: int :param namespace: :type namespace: str :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef logs_jobs_uid_logs_get_without_preload_content(\n    self,\n    uid: StrictStr,\n    stream: StrictBool | None = None,\n    tail: StrictInt | None = None,\n    namespace: StrictStr | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Logs\n\n\n    :param uid: (required)\n    :type uid: str\n    :param stream:\n    :type stream: bool\n    :param tail:\n    :type tail: int\n    :param namespace:\n    :type namespace: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._logs_jobs_uid_logs_get_serialize(\n        uid=uid,\n        stream=stream,\n        tail=tail,\n        namespace=namespace,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"object\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.status_jobs_uid_status_get","title":"status_jobs_uid_status_get","text":"<pre><code>status_jobs_uid_status_get(\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object\n</code></pre> <p>Status</p> <p>:param uid: (required) :type uid: str :param namespace: :type namespace: str :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef status_jobs_uid_status_get(\n    self,\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Status\n\n\n    :param uid: (required)\n    :type uid: str\n    :param namespace:\n    :type namespace: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._status_jobs_uid_status_get_serialize(\n        uid=uid,\n        namespace=namespace,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"object\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.status_jobs_uid_status_get_with_http_info","title":"status_jobs_uid_status_get_with_http_info","text":"<pre><code>status_jobs_uid_status_get_with_http_info(\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]\n</code></pre> <p>Status</p> <p>:param uid: (required) :type uid: str :param namespace: :type namespace: str :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef status_jobs_uid_status_get_with_http_info(\n    self,\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Status\n\n\n    :param uid: (required)\n    :type uid: str\n    :param namespace:\n    :type namespace: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._status_jobs_uid_status_get_serialize(\n        uid=uid,\n        namespace=namespace,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"object\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.status_jobs_uid_status_get_without_preload_content","title":"status_jobs_uid_status_get_without_preload_content","text":"<pre><code>status_jobs_uid_status_get_without_preload_content(\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType\n</code></pre> <p>Status</p> <p>:param uid: (required) :type uid: str :param namespace: :type namespace: str :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef status_jobs_uid_status_get_without_preload_content(\n    self,\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Status\n\n\n    :param uid: (required)\n    :type uid: str\n    :param namespace:\n    :type namespace: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._status_jobs_uid_status_get_serialize(\n        uid=uid,\n        namespace=namespace,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"object\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.stop_workload_jobs_uid_stop_post","title":"stop_workload_jobs_uid_stop_post","text":"<pre><code>stop_workload_jobs_uid_stop_post(\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object\n</code></pre> <p>Stop Workload</p> <p>:param uid: (required) :type uid: str :param namespace: :type namespace: str :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef stop_workload_jobs_uid_stop_post(\n    self,\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Stop Workload\n\n\n    :param uid: (required)\n    :type uid: str\n    :param namespace:\n    :type namespace: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._stop_workload_jobs_uid_stop_post_serialize(\n        uid=uid,\n        namespace=namespace,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"object\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.stop_workload_jobs_uid_stop_post_with_http_info","title":"stop_workload_jobs_uid_stop_post_with_http_info","text":"<pre><code>stop_workload_jobs_uid_stop_post_with_http_info(\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]\n</code></pre> <p>Stop Workload</p> <p>:param uid: (required) :type uid: str :param namespace: :type namespace: str :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef stop_workload_jobs_uid_stop_post_with_http_info(\n    self,\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Stop Workload\n\n\n    :param uid: (required)\n    :type uid: str\n    :param namespace:\n    :type namespace: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._stop_workload_jobs_uid_stop_post_serialize(\n        uid=uid,\n        namespace=namespace,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"object\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.stop_workload_jobs_uid_stop_post_without_preload_content","title":"stop_workload_jobs_uid_stop_post_without_preload_content","text":"<pre><code>stop_workload_jobs_uid_stop_post_without_preload_content(\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType\n</code></pre> <p>Stop Workload</p> <p>:param uid: (required) :type uid: str :param namespace: :type namespace: str :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef stop_workload_jobs_uid_stop_post_without_preload_content(\n    self,\n    uid: StrictStr,\n    namespace: StrictStr | None = None,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Stop Workload\n\n\n    :param uid: (required)\n    :type uid: str\n    :param namespace:\n    :type namespace: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._stop_workload_jobs_uid_stop_post_serialize(\n        uid=uid,\n        namespace=namespace,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"object\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.submit_job_jobs_post","title":"submit_job_jobs_post","text":"<pre><code>submit_job_jobs_post(\n    create_job_model: CreateJobModel,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; WorkloadIdentifier\n</code></pre> <p>Submit Job</p> <p>:param create_job_model: (required) :type create_job_model: CreateJobModel :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef submit_job_jobs_post(\n    self,\n    create_job_model: CreateJobModel,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; WorkloadIdentifier:\n    \"\"\"Submit Job\n\n\n    :param create_job_model: (required)\n    :type create_job_model: CreateJobModel\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._submit_job_jobs_post_serialize(\n        create_job_model=create_job_model,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"WorkloadIdentifier\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.submit_job_jobs_post_with_http_info","title":"submit_job_jobs_post_with_http_info","text":"<pre><code>submit_job_jobs_post_with_http_info(\n    create_job_model: CreateJobModel,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[WorkloadIdentifier]\n</code></pre> <p>Submit Job</p> <p>:param create_job_model: (required) :type create_job_model: CreateJobModel :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef submit_job_jobs_post_with_http_info(\n    self,\n    create_job_model: CreateJobModel,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[WorkloadIdentifier]:\n    \"\"\"Submit Job\n\n\n    :param create_job_model: (required)\n    :type create_job_model: CreateJobModel\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._submit_job_jobs_post_serialize(\n        create_job_model=create_job_model,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"WorkloadIdentifier\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"reference/openapi_client/api/job_management_api/#openapi_client.api.job_management_api.JobManagementApi.submit_job_jobs_post_without_preload_content","title":"submit_job_jobs_post_without_preload_content","text":"<pre><code>submit_job_jobs_post_without_preload_content(\n    create_job_model: CreateJobModel,\n    _request_timeout: (\n        None\n        | Annotated[StrictFloat, Field(gt=0)]\n        | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]\n    ) = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType\n</code></pre> <p>Submit Job</p> <p>:param create_job_model: (required) :type create_job_model: CreateJobModel :param _request_timeout: timeout setting for this request. If one                          number provided, it will be total request                          timeout. It can also be a pair (tuple) of                          (connection, read) timeouts. :type _request_timeout: int, tuple(int, int), optional :param _request_auth: set to override the auth_settings for an a single                       request; this effectively ignores the                       authentication in the spec for a single request. :type _request_auth: dict, optional :param _content_type: force content-type for the request. :type _content_type: str, Optional :param _headers: set to override the headers for a single                  request; this effectively ignores the headers                  in the spec for a single request. :type _headers: dict, optional :param _host_index: set to override the host_index for a single                     request; this effectively ignores the host_index                     in the spec for a single request. :type _host_index: int, optional :return: Returns the result object.</p> Source code in <code>src/openapi_client/api/job_management_api.py</code> <pre><code>@validate_call\ndef submit_job_jobs_post_without_preload_content(\n    self,\n    create_job_model: CreateJobModel,\n    _request_timeout: None\n    | Annotated[StrictFloat, Field(gt=0)]\n    | tuple[\n        Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]\n    ] = None,\n    _request_auth: dict[StrictStr, Any] | None = None,\n    _content_type: StrictStr | None = None,\n    _headers: dict[StrictStr, Any] | None = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Submit Job\n\n\n    :param create_job_model: (required)\n    :type create_job_model: CreateJobModel\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\"  # noqa: E501\n\n    _param = self._submit_job_jobs_post_serialize(\n        create_job_model=create_job_model,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index,\n    )\n\n    _response_types_map: dict[str, str | None] = {\n        \"200\": \"WorkloadIdentifier\",\n        \"422\": \"HTTPValidationError\",\n    }\n    response_data = self.api_client.call_api(\n        *_param, _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"reference/openapi_client/models/","title":"models","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/create_job_model/","title":"create_job_model","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/create_job_model/#openapi_client.models.create_job_model.CreateJobModel","title":"CreateJobModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>CreateJobModel</p> Source code in <code>src/openapi_client/models/create_job_model.py</code> <pre><code>class CreateJobModel(BaseModel):\n    \"\"\"\n    CreateJobModel\n    \"\"\"  # noqa: E501\n\n    name: StrictStr\n    file: StrictStr\n    image_ref: StrictStr\n    mode: ExecutionMode\n    options: JobOptions\n    submission_context: dict[str, Any] | None = None\n    __properties: ClassVar[list[str]] = [\n        \"name\",\n        \"file\",\n        \"image_ref\",\n        \"mode\",\n        \"options\",\n        \"submission_context\",\n    ]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of CreateJobModel from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # override the default output from pydantic by calling `to_dict()` of options\n        if self.options:\n            _dict[\"options\"] = self.options.to_dict()\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of CreateJobModel from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"name\": obj.get(\"name\"),\n            \"file\": obj.get(\"file\"),\n            \"image_ref\": obj.get(\"image_ref\"),\n            \"mode\": obj.get(\"mode\"),\n            \"options\": JobOptions.from_dict(obj[\"options\"])\n            if obj.get(\"options\") is not None\n            else None,\n            \"submission_context\": obj.get(\"submission_context\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/create_job_model/#openapi_client.models.create_job_model.CreateJobModel.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>src/openapi_client/models/create_job_model.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/create_job_model/#openapi_client.models.create_job_model.CreateJobModel.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>src/openapi_client/models/create_job_model.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/create_job_model/#openapi_client.models.create_job_model.CreateJobModel.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of CreateJobModel from a JSON string</p> Source code in <code>src/openapi_client/models/create_job_model.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of CreateJobModel from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/create_job_model/#openapi_client.models.create_job_model.CreateJobModel.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>src/openapi_client/models/create_job_model.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # override the default output from pydantic by calling `to_dict()` of options\n    if self.options:\n        _dict[\"options\"] = self.options.to_dict()\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/create_job_model/#openapi_client.models.create_job_model.CreateJobModel.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of CreateJobModel from a dict</p> Source code in <code>src/openapi_client/models/create_job_model.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of CreateJobModel from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"name\": obj.get(\"name\"),\n        \"file\": obj.get(\"file\"),\n        \"image_ref\": obj.get(\"image_ref\"),\n        \"mode\": obj.get(\"mode\"),\n        \"options\": JobOptions.from_dict(obj[\"options\"])\n        if obj.get(\"options\") is not None\n        else None,\n        \"submission_context\": obj.get(\"submission_context\"),\n    })\n    return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/execution_mode/","title":"execution_mode","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/execution_mode/#openapi_client.models.execution_mode.ExecutionMode","title":"ExecutionMode","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>ExecutionMode</p> Source code in <code>src/openapi_client/models/execution_mode.py</code> <pre><code>class ExecutionMode(str, Enum):\n    \"\"\"\n    ExecutionMode\n    \"\"\"\n\n    \"\"\"\n    allowed enum values\n    \"\"\"\n    LOCAL = \"local\"\n    DOCKER = \"docker\"\n    KUEUE = \"kueue\"\n    RAYCLUSTER = \"raycluster\"\n    RAYJOB = \"rayjob\"\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self:\n        \"\"\"Create an instance of ExecutionMode from a JSON string\"\"\"\n        return cls(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/execution_mode/#openapi_client.models.execution_mode.ExecutionMode.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self\n</code></pre> <p>Create an instance of ExecutionMode from a JSON string</p> Source code in <code>src/openapi_client/models/execution_mode.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self:\n    \"\"\"Create an instance of ExecutionMode from a JSON string\"\"\"\n    return cls(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/http_validation_error/","title":"http_validation_error","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/http_validation_error/#openapi_client.models.http_validation_error.HTTPValidationError","title":"HTTPValidationError","text":"<p>               Bases: <code>BaseModel</code></p> <p>HTTPValidationError</p> Source code in <code>src/openapi_client/models/http_validation_error.py</code> <pre><code>class HTTPValidationError(BaseModel):\n    \"\"\"\n    HTTPValidationError\n    \"\"\"  # noqa: E501\n\n    detail: list[ValidationError] | None = None\n    __properties: ClassVar[list[str]] = [\"detail\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of HTTPValidationError from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # override the default output from pydantic by calling `to_dict()` of each item in detail (list)\n        _items = []\n        if self.detail:\n            for _item_detail in self.detail:\n                if _item_detail:\n                    _items.append(_item_detail.to_dict())\n            _dict[\"detail\"] = _items\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of HTTPValidationError from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"detail\": [ValidationError.from_dict(_item) for _item in obj[\"detail\"]]\n            if obj.get(\"detail\") is not None\n            else None\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/http_validation_error/#openapi_client.models.http_validation_error.HTTPValidationError.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>src/openapi_client/models/http_validation_error.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/http_validation_error/#openapi_client.models.http_validation_error.HTTPValidationError.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>src/openapi_client/models/http_validation_error.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/http_validation_error/#openapi_client.models.http_validation_error.HTTPValidationError.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of HTTPValidationError from a JSON string</p> Source code in <code>src/openapi_client/models/http_validation_error.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of HTTPValidationError from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/http_validation_error/#openapi_client.models.http_validation_error.HTTPValidationError.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>src/openapi_client/models/http_validation_error.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # override the default output from pydantic by calling `to_dict()` of each item in detail (list)\n    _items = []\n    if self.detail:\n        for _item_detail in self.detail:\n            if _item_detail:\n                _items.append(_item_detail.to_dict())\n        _dict[\"detail\"] = _items\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/http_validation_error/#openapi_client.models.http_validation_error.HTTPValidationError.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of HTTPValidationError from a dict</p> Source code in <code>src/openapi_client/models/http_validation_error.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of HTTPValidationError from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"detail\": [ValidationError.from_dict(_item) for _item in obj[\"detail\"]]\n        if obj.get(\"detail\") is not None\n        else None\n    })\n    return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/job_options/","title":"job_options","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/job_options/#openapi_client.models.job_options.JobOptions","title":"JobOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>JobOptions</p> Source code in <code>src/openapi_client/models/job_options.py</code> <pre><code>class JobOptions(BaseModel):\n    \"\"\"\n    JobOptions\n    \"\"\"  # noqa: E501\n\n    resources: ResourceOptions | None = None\n    scheduling: SchedulingOptions | None = None\n    labels: dict[str, StrictStr] | None = None\n    __properties: ClassVar[list[str]] = [\"resources\", \"scheduling\", \"labels\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of JobOptions from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # override the default output from pydantic by calling `to_dict()` of resources\n        if self.resources:\n            _dict[\"resources\"] = self.resources.to_dict()\n        # override the default output from pydantic by calling `to_dict()` of scheduling\n        if self.scheduling:\n            _dict[\"scheduling\"] = self.scheduling.to_dict()\n        # set to None if resources (nullable) is None\n        # and model_fields_set contains the field\n        if self.resources is None and \"resources\" in self.model_fields_set:\n            _dict[\"resources\"] = None\n\n        # set to None if scheduling (nullable) is None\n        # and model_fields_set contains the field\n        if self.scheduling is None and \"scheduling\" in self.model_fields_set:\n            _dict[\"scheduling\"] = None\n\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of JobOptions from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"resources\": ResourceOptions.from_dict(obj[\"resources\"])\n            if obj.get(\"resources\") is not None\n            else None,\n            \"scheduling\": SchedulingOptions.from_dict(obj[\"scheduling\"])\n            if obj.get(\"scheduling\") is not None\n            else None,\n            \"labels\": obj.get(\"labels\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/job_options/#openapi_client.models.job_options.JobOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>src/openapi_client/models/job_options.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/job_options/#openapi_client.models.job_options.JobOptions.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>src/openapi_client/models/job_options.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/job_options/#openapi_client.models.job_options.JobOptions.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of JobOptions from a JSON string</p> Source code in <code>src/openapi_client/models/job_options.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of JobOptions from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/job_options/#openapi_client.models.job_options.JobOptions.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>src/openapi_client/models/job_options.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # override the default output from pydantic by calling `to_dict()` of resources\n    if self.resources:\n        _dict[\"resources\"] = self.resources.to_dict()\n    # override the default output from pydantic by calling `to_dict()` of scheduling\n    if self.scheduling:\n        _dict[\"scheduling\"] = self.scheduling.to_dict()\n    # set to None if resources (nullable) is None\n    # and model_fields_set contains the field\n    if self.resources is None and \"resources\" in self.model_fields_set:\n        _dict[\"resources\"] = None\n\n    # set to None if scheduling (nullable) is None\n    # and model_fields_set contains the field\n    if self.scheduling is None and \"scheduling\" in self.model_fields_set:\n        _dict[\"scheduling\"] = None\n\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/job_options/#openapi_client.models.job_options.JobOptions.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of JobOptions from a dict</p> Source code in <code>src/openapi_client/models/job_options.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of JobOptions from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"resources\": ResourceOptions.from_dict(obj[\"resources\"])\n        if obj.get(\"resources\") is not None\n        else None,\n        \"scheduling\": SchedulingOptions.from_dict(obj[\"scheduling\"])\n        if obj.get(\"scheduling\") is not None\n        else None,\n        \"labels\": obj.get(\"labels\"),\n    })\n    return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/resource_options/","title":"resource_options","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/resource_options/#openapi_client.models.resource_options.ResourceOptions","title":"ResourceOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>ResourceOptions</p> Source code in <code>src/openapi_client/models/resource_options.py</code> <pre><code>class ResourceOptions(BaseModel):\n    \"\"\"\n    ResourceOptions\n    \"\"\"  # noqa: E501\n\n    memory: StrictStr | None = None\n    cpu: StrictStr | None = None\n    gpu: StrictInt | None = None\n    __properties: ClassVar[list[str]] = [\"memory\", \"cpu\", \"gpu\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of ResourceOptions from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # set to None if memory (nullable) is None\n        # and model_fields_set contains the field\n        if self.memory is None and \"memory\" in self.model_fields_set:\n            _dict[\"memory\"] = None\n\n        # set to None if cpu (nullable) is None\n        # and model_fields_set contains the field\n        if self.cpu is None and \"cpu\" in self.model_fields_set:\n            _dict[\"cpu\"] = None\n\n        # set to None if gpu (nullable) is None\n        # and model_fields_set contains the field\n        if self.gpu is None and \"gpu\" in self.model_fields_set:\n            _dict[\"gpu\"] = None\n\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of ResourceOptions from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"memory\": obj.get(\"memory\"),\n            \"cpu\": obj.get(\"cpu\"),\n            \"gpu\": obj.get(\"gpu\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/resource_options/#openapi_client.models.resource_options.ResourceOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>src/openapi_client/models/resource_options.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/resource_options/#openapi_client.models.resource_options.ResourceOptions.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>src/openapi_client/models/resource_options.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/resource_options/#openapi_client.models.resource_options.ResourceOptions.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of ResourceOptions from a JSON string</p> Source code in <code>src/openapi_client/models/resource_options.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of ResourceOptions from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/resource_options/#openapi_client.models.resource_options.ResourceOptions.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>src/openapi_client/models/resource_options.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # set to None if memory (nullable) is None\n    # and model_fields_set contains the field\n    if self.memory is None and \"memory\" in self.model_fields_set:\n        _dict[\"memory\"] = None\n\n    # set to None if cpu (nullable) is None\n    # and model_fields_set contains the field\n    if self.cpu is None and \"cpu\" in self.model_fields_set:\n        _dict[\"cpu\"] = None\n\n    # set to None if gpu (nullable) is None\n    # and model_fields_set contains the field\n    if self.gpu is None and \"gpu\" in self.model_fields_set:\n        _dict[\"gpu\"] = None\n\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/resource_options/#openapi_client.models.resource_options.ResourceOptions.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of ResourceOptions from a dict</p> Source code in <code>src/openapi_client/models/resource_options.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of ResourceOptions from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"memory\": obj.get(\"memory\"),\n        \"cpu\": obj.get(\"cpu\"),\n        \"gpu\": obj.get(\"gpu\"),\n    })\n    return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/scheduling_options/","title":"scheduling_options","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/scheduling_options/#openapi_client.models.scheduling_options.SchedulingOptions","title":"SchedulingOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>SchedulingOptions</p> Source code in <code>src/openapi_client/models/scheduling_options.py</code> <pre><code>class SchedulingOptions(BaseModel):\n    \"\"\"\n    SchedulingOptions\n    \"\"\"  # noqa: E501\n\n    priority_class: StrictStr | None = None\n    queue_name: StrictStr | None = None\n    __properties: ClassVar[list[str]] = [\"priority_class\", \"queue_name\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of SchedulingOptions from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # set to None if priority_class (nullable) is None\n        # and model_fields_set contains the field\n        if self.priority_class is None and \"priority_class\" in self.model_fields_set:\n            _dict[\"priority_class\"] = None\n\n        # set to None if queue_name (nullable) is None\n        # and model_fields_set contains the field\n        if self.queue_name is None and \"queue_name\" in self.model_fields_set:\n            _dict[\"queue_name\"] = None\n\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of SchedulingOptions from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"priority_class\": obj.get(\"priority_class\"),\n            \"queue_name\": obj.get(\"queue_name\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/scheduling_options/#openapi_client.models.scheduling_options.SchedulingOptions.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>src/openapi_client/models/scheduling_options.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/scheduling_options/#openapi_client.models.scheduling_options.SchedulingOptions.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>src/openapi_client/models/scheduling_options.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/scheduling_options/#openapi_client.models.scheduling_options.SchedulingOptions.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of SchedulingOptions from a JSON string</p> Source code in <code>src/openapi_client/models/scheduling_options.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of SchedulingOptions from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/scheduling_options/#openapi_client.models.scheduling_options.SchedulingOptions.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>src/openapi_client/models/scheduling_options.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # set to None if priority_class (nullable) is None\n    # and model_fields_set contains the field\n    if self.priority_class is None and \"priority_class\" in self.model_fields_set:\n        _dict[\"priority_class\"] = None\n\n    # set to None if queue_name (nullable) is None\n    # and model_fields_set contains the field\n    if self.queue_name is None and \"queue_name\" in self.model_fields_set:\n        _dict[\"queue_name\"] = None\n\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/scheduling_options/#openapi_client.models.scheduling_options.SchedulingOptions.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of SchedulingOptions from a dict</p> Source code in <code>src/openapi_client/models/scheduling_options.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of SchedulingOptions from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"priority_class\": obj.get(\"priority_class\"),\n        \"queue_name\": obj.get(\"queue_name\"),\n    })\n    return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error/","title":"validation_error","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/validation_error/#openapi_client.models.validation_error.ValidationError","title":"ValidationError","text":"<p>               Bases: <code>BaseModel</code></p> <p>ValidationError</p> Source code in <code>src/openapi_client/models/validation_error.py</code> <pre><code>class ValidationError(BaseModel):\n    \"\"\"\n    ValidationError\n    \"\"\"  # noqa: E501\n\n    loc: list[ValidationErrorLocInner]\n    msg: StrictStr\n    type: StrictStr\n    __properties: ClassVar[list[str]] = [\"loc\", \"msg\", \"type\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of ValidationError from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        # override the default output from pydantic by calling `to_dict()` of each item in loc (list)\n        _items = []\n        if self.loc:\n            for _item_loc in self.loc:\n                if _item_loc:\n                    _items.append(_item_loc.to_dict())\n            _dict[\"loc\"] = _items\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of ValidationError from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"loc\": [ValidationErrorLocInner.from_dict(_item) for _item in obj[\"loc\"]]\n            if obj.get(\"loc\") is not None\n            else None,\n            \"msg\": obj.get(\"msg\"),\n            \"type\": obj.get(\"type\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error/#openapi_client.models.validation_error.ValidationError.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>src/openapi_client/models/validation_error.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error/#openapi_client.models.validation_error.ValidationError.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>src/openapi_client/models/validation_error.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error/#openapi_client.models.validation_error.ValidationError.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of ValidationError from a JSON string</p> Source code in <code>src/openapi_client/models/validation_error.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of ValidationError from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error/#openapi_client.models.validation_error.ValidationError.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>src/openapi_client/models/validation_error.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    # override the default output from pydantic by calling `to_dict()` of each item in loc (list)\n    _items = []\n    if self.loc:\n        for _item_loc in self.loc:\n            if _item_loc:\n                _items.append(_item_loc.to_dict())\n        _dict[\"loc\"] = _items\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error/#openapi_client.models.validation_error.ValidationError.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of ValidationError from a dict</p> Source code in <code>src/openapi_client/models/validation_error.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of ValidationError from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"loc\": [ValidationErrorLocInner.from_dict(_item) for _item in obj[\"loc\"]]\n        if obj.get(\"loc\") is not None\n        else None,\n        \"msg\": obj.get(\"msg\"),\n        \"type\": obj.get(\"type\"),\n    })\n    return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error_loc_inner/","title":"validation_error_loc_inner","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/validation_error_loc_inner/#openapi_client.models.validation_error_loc_inner.ValidationErrorLocInner","title":"ValidationErrorLocInner","text":"<p>               Bases: <code>BaseModel</code></p> <p>ValidationErrorLocInner</p> Source code in <code>src/openapi_client/models/validation_error_loc_inner.py</code> <pre><code>class ValidationErrorLocInner(BaseModel):\n    \"\"\"\n    ValidationErrorLocInner\n    \"\"\"\n\n    # data type: str\n    anyof_schema_1_validator: StrictStr | None = None\n    # data type: int\n    anyof_schema_2_validator: StrictInt | None = None\n    if TYPE_CHECKING:\n        actual_instance: int | str | None = None\n    else:\n        actual_instance: Any = None\n    any_of_schemas: set[str] = {\"int\", \"str\"}\n\n    model_config = {\n        \"validate_assignment\": True,\n        \"protected_namespaces\": (),\n    }\n\n    def __init__(self, *args, **kwargs) -&gt; None:\n        if args:\n            if len(args) &gt; 1:\n                raise ValueError(\n                    \"If a position argument is used, only 1 is allowed to set `actual_instance`\"\n                )\n            if kwargs:\n                raise ValueError(\n                    \"If a position argument is used, keyword arguments cannot be used.\"\n                )\n            super().__init__(actual_instance=args[0])\n        else:\n            super().__init__(**kwargs)\n\n    @field_validator(\"actual_instance\")\n    def actual_instance_must_validate_anyof(cls, v):\n        instance = ValidationErrorLocInner.model_construct()\n        error_messages = []\n        # validate data type: str\n        try:\n            instance.anyof_schema_1_validator = v\n            return v\n        except (ValidationError, ValueError) as e:\n            error_messages.append(str(e))\n        # validate data type: int\n        try:\n            instance.anyof_schema_2_validator = v\n            return v\n        except (ValidationError, ValueError) as e:\n            error_messages.append(str(e))\n        if error_messages:\n            # no match\n            raise ValueError(\n                \"No match found when setting the actual_instance in ValidationErrorLocInner with anyOf schemas: int, str. Details: \"\n                + \", \".join(error_messages)\n            )\n        else:\n            return v\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any]) -&gt; Self:\n        return cls.from_json(json.dumps(obj))\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self:\n        \"\"\"Returns the object represented by the json string\"\"\"\n        instance = cls.model_construct()\n        error_messages = []\n        # deserialize data into str\n        try:\n            # validation\n            instance.anyof_schema_1_validator = json.loads(json_str)\n            # assign value to actual_instance\n            instance.actual_instance = instance.anyof_schema_1_validator\n            return instance\n        except (ValidationError, ValueError) as e:\n            error_messages.append(str(e))\n        # deserialize data into int\n        try:\n            # validation\n            instance.anyof_schema_2_validator = json.loads(json_str)\n            # assign value to actual_instance\n            instance.actual_instance = instance.anyof_schema_2_validator\n            return instance\n        except (ValidationError, ValueError) as e:\n            error_messages.append(str(e))\n\n        if error_messages:\n            # no match\n            raise ValueError(\n                \"No match found when deserializing the JSON string into ValidationErrorLocInner with anyOf schemas: int, str. Details: \"\n                + \", \".join(error_messages)\n            )\n        else:\n            return instance\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the actual instance\"\"\"\n        if self.actual_instance is None:\n            return \"null\"\n\n        if hasattr(self.actual_instance, \"to_json\") and callable(\n            self.actual_instance.to_json\n        ):\n            return self.actual_instance.to_json()\n        else:\n            return json.dumps(self.actual_instance)\n\n    def to_dict(self) -&gt; dict[str, Any] | int | str | None:\n        \"\"\"Returns the dict representation of the actual instance\"\"\"\n        if self.actual_instance is None:\n            return None\n\n        if hasattr(self.actual_instance, \"to_dict\") and callable(\n            self.actual_instance.to_dict\n        ):\n            return self.actual_instance.to_dict()\n        else:\n            return self.actual_instance\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the actual instance\"\"\"\n        return pprint.pformat(self.model_dump())\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error_loc_inner/#openapi_client.models.validation_error_loc_inner.ValidationErrorLocInner.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self\n</code></pre> <p>Returns the object represented by the json string</p> Source code in <code>src/openapi_client/models/validation_error_loc_inner.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self:\n    \"\"\"Returns the object represented by the json string\"\"\"\n    instance = cls.model_construct()\n    error_messages = []\n    # deserialize data into str\n    try:\n        # validation\n        instance.anyof_schema_1_validator = json.loads(json_str)\n        # assign value to actual_instance\n        instance.actual_instance = instance.anyof_schema_1_validator\n        return instance\n    except (ValidationError, ValueError) as e:\n        error_messages.append(str(e))\n    # deserialize data into int\n    try:\n        # validation\n        instance.anyof_schema_2_validator = json.loads(json_str)\n        # assign value to actual_instance\n        instance.actual_instance = instance.anyof_schema_2_validator\n        return instance\n    except (ValidationError, ValueError) as e:\n        error_messages.append(str(e))\n\n    if error_messages:\n        # no match\n        raise ValueError(\n            \"No match found when deserializing the JSON string into ValidationErrorLocInner with anyOf schemas: int, str. Details: \"\n            + \", \".join(error_messages)\n        )\n    else:\n        return instance\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error_loc_inner/#openapi_client.models.validation_error_loc_inner.ValidationErrorLocInner.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the actual instance</p> Source code in <code>src/openapi_client/models/validation_error_loc_inner.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the actual instance\"\"\"\n    if self.actual_instance is None:\n        return \"null\"\n\n    if hasattr(self.actual_instance, \"to_json\") and callable(\n        self.actual_instance.to_json\n    ):\n        return self.actual_instance.to_json()\n    else:\n        return json.dumps(self.actual_instance)\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error_loc_inner/#openapi_client.models.validation_error_loc_inner.ValidationErrorLocInner.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any] | int | str | None\n</code></pre> <p>Returns the dict representation of the actual instance</p> Source code in <code>src/openapi_client/models/validation_error_loc_inner.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any] | int | str | None:\n    \"\"\"Returns the dict representation of the actual instance\"\"\"\n    if self.actual_instance is None:\n        return None\n\n    if hasattr(self.actual_instance, \"to_dict\") and callable(\n        self.actual_instance.to_dict\n    ):\n        return self.actual_instance.to_dict()\n    else:\n        return self.actual_instance\n</code></pre>"},{"location":"reference/openapi_client/models/validation_error_loc_inner/#openapi_client.models.validation_error_loc_inner.ValidationErrorLocInner.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the actual instance</p> Source code in <code>src/openapi_client/models/validation_error_loc_inner.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the actual instance\"\"\"\n    return pprint.pformat(self.model_dump())\n</code></pre>"},{"location":"reference/openapi_client/models/workload_identifier/","title":"workload_identifier","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/models/workload_identifier/#openapi_client.models.workload_identifier.WorkloadIdentifier","title":"WorkloadIdentifier","text":"<p>               Bases: <code>BaseModel</code></p> <p>Identifier for a workload in a Kubernetes cluster</p> Source code in <code>src/openapi_client/models/workload_identifier.py</code> <pre><code>class WorkloadIdentifier(BaseModel):\n    \"\"\"\n    Identifier for a workload in a Kubernetes cluster\n    \"\"\"  # noqa: E501\n\n    group: StrictStr\n    version: StrictStr\n    kind: StrictStr\n    namespace: StrictStr\n    uid: StrictStr\n    __properties: ClassVar[list[str]] = [\"group\", \"version\", \"kind\", \"namespace\", \"uid\"]\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        validate_assignment=True,\n        protected_namespaces=(),\n    )\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self | None:\n        \"\"\"Create an instance of WorkloadIdentifier from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        excluded_fields: set[str] = set()\n\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude=excluded_fields,\n            exclude_none=True,\n        )\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n        \"\"\"Create an instance of WorkloadIdentifier from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"group\": obj.get(\"group\"),\n            \"version\": obj.get(\"version\"),\n            \"kind\": obj.get(\"kind\"),\n            \"namespace\": obj.get(\"namespace\"),\n            \"uid\": obj.get(\"uid\"),\n        })\n        return _obj\n</code></pre>"},{"location":"reference/openapi_client/models/workload_identifier/#openapi_client.models.workload_identifier.WorkloadIdentifier.to_str","title":"to_str","text":"<pre><code>to_str() -&gt; str\n</code></pre> <p>Returns the string representation of the model using alias</p> Source code in <code>src/openapi_client/models/workload_identifier.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"reference/openapi_client/models/workload_identifier/#openapi_client.models.workload_identifier.WorkloadIdentifier.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Returns the JSON representation of the model using alias</p> Source code in <code>src/openapi_client/models/workload_identifier.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"reference/openapi_client/models/workload_identifier/#openapi_client.models.workload_identifier.WorkloadIdentifier.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_str: str) -&gt; Self | None\n</code></pre> <p>Create an instance of WorkloadIdentifier from a JSON string</p> Source code in <code>src/openapi_client/models/workload_identifier.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self | None:\n    \"\"\"Create an instance of WorkloadIdentifier from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"reference/openapi_client/models/workload_identifier/#openapi_client.models.workload_identifier.WorkloadIdentifier.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>src/openapi_client/models/workload_identifier.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    excluded_fields: set[str] = set()\n\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude=excluded_fields,\n        exclude_none=True,\n    )\n    return _dict\n</code></pre>"},{"location":"reference/openapi_client/models/workload_identifier/#openapi_client.models.workload_identifier.WorkloadIdentifier.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(obj: dict[str, Any] | None) -&gt; Self | None\n</code></pre> <p>Create an instance of WorkloadIdentifier from a dict</p> Source code in <code>src/openapi_client/models/workload_identifier.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: dict[str, Any] | None) -&gt; Self | None:\n    \"\"\"Create an instance of WorkloadIdentifier from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"group\": obj.get(\"group\"),\n        \"version\": obj.get(\"version\"),\n        \"kind\": obj.get(\"kind\"),\n        \"namespace\": obj.get(\"namespace\"),\n        \"uid\": obj.get(\"uid\"),\n    })\n    return _obj\n</code></pre>"},{"location":"reference/openapi_client/test/","title":"test","text":""},{"location":"reference/openapi_client/test/test_create_job_model/","title":"test_create_job_model","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/test/test_create_job_model/#openapi_client.test.test_create_job_model.TestCreateJobModel","title":"TestCreateJobModel","text":"<p>               Bases: <code>TestCase</code></p> <p>CreateJobModel unit test stubs</p> Source code in <code>src/openapi_client/test/test_create_job_model.py</code> <pre><code>class TestCreateJobModel(unittest.TestCase):\n    \"\"\"CreateJobModel unit test stubs\"\"\"\n\n    def setUp(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def make_instance(self, include_optional) -&gt; CreateJobModel:\n        \"\"\"Test CreateJobModel\n        include_optional is a boolean, when False only required\n        params are included, when True both required and\n        optional params are included\"\"\"\n        # uncomment below to create an instance of `CreateJobModel`\n        \"\"\"\n        model = CreateJobModel()\n        if include_optional:\n            return CreateJobModel(\n                name = '',\n                file = '',\n                image_ref = '',\n                mode = 'local',\n                options = openapi_client.models.job_options.JobOptions(\n                    resources = openapi_client.models.resource_options.ResourceOptions(\n                        memory = '',\n                        cpu = '',\n                        gpu = 56, ),\n                    scheduling = openapi_client.models.scheduling_options.SchedulingOptions(\n                        priority_class = '',\n                        queue_name = '', ),\n                    labels = {\n                        'key' : ''\n                        }, ),\n                submission_context = openapi_client.models.submission_context.Submission Context()\n            )\n        else:\n            return CreateJobModel(\n                name = '',\n                file = '',\n                image_ref = '',\n                mode = 'local',\n                options = openapi_client.models.job_options.JobOptions(\n                    resources = openapi_client.models.resource_options.ResourceOptions(\n                        memory = '',\n                        cpu = '',\n                        gpu = 56, ),\n                    scheduling = openapi_client.models.scheduling_options.SchedulingOptions(\n                        priority_class = '',\n                        queue_name = '', ),\n                    labels = {\n                        'key' : ''\n                        }, ),\n        )\n        \"\"\"\n\n    def testCreateJobModel(self):\n        \"\"\"Test CreateJobModel\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_create_job_model/#openapi_client.test.test_create_job_model.TestCreateJobModel.make_instance","title":"make_instance","text":"<pre><code>make_instance(include_optional) -&gt; CreateJobModel\n</code></pre> <p>Test CreateJobModel include_optional is a boolean, when False only required params are included, when True both required and optional params are included</p> Source code in <code>src/openapi_client/test/test_create_job_model.py</code> <pre><code>def make_instance(self, include_optional) -&gt; CreateJobModel:\n    \"\"\"Test CreateJobModel\n    include_optional is a boolean, when False only required\n    params are included, when True both required and\n    optional params are included\"\"\"\n    # uncomment below to create an instance of `CreateJobModel`\n    \"\"\"\n    model = CreateJobModel()\n    if include_optional:\n        return CreateJobModel(\n            name = '',\n            file = '',\n            image_ref = '',\n            mode = 'local',\n            options = openapi_client.models.job_options.JobOptions(\n                resources = openapi_client.models.resource_options.ResourceOptions(\n                    memory = '',\n                    cpu = '',\n                    gpu = 56, ),\n                scheduling = openapi_client.models.scheduling_options.SchedulingOptions(\n                    priority_class = '',\n                    queue_name = '', ),\n                labels = {\n                    'key' : ''\n                    }, ),\n            submission_context = openapi_client.models.submission_context.Submission Context()\n        )\n    else:\n        return CreateJobModel(\n            name = '',\n            file = '',\n            image_ref = '',\n            mode = 'local',\n            options = openapi_client.models.job_options.JobOptions(\n                resources = openapi_client.models.resource_options.ResourceOptions(\n                    memory = '',\n                    cpu = '',\n                    gpu = 56, ),\n                scheduling = openapi_client.models.scheduling_options.SchedulingOptions(\n                    priority_class = '',\n                    queue_name = '', ),\n                labels = {\n                    'key' : ''\n                    }, ),\n    )\n    \"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_create_job_model/#openapi_client.test.test_create_job_model.TestCreateJobModel.testCreateJobModel","title":"testCreateJobModel","text":"<pre><code>testCreateJobModel()\n</code></pre> <p>Test CreateJobModel</p> Source code in <code>src/openapi_client/test/test_create_job_model.py</code> <pre><code>def testCreateJobModel(self):\n    \"\"\"Test CreateJobModel\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_execution_mode/","title":"test_execution_mode","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/test/test_execution_mode/#openapi_client.test.test_execution_mode.TestExecutionMode","title":"TestExecutionMode","text":"<p>               Bases: <code>TestCase</code></p> <p>ExecutionMode unit test stubs</p> Source code in <code>src/openapi_client/test/test_execution_mode.py</code> <pre><code>class TestExecutionMode(unittest.TestCase):\n    \"\"\"ExecutionMode unit test stubs\"\"\"\n\n    def setUp(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def testExecutionMode(self):\n        \"\"\"Test ExecutionMode\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_execution_mode/#openapi_client.test.test_execution_mode.TestExecutionMode.testExecutionMode","title":"testExecutionMode","text":"<pre><code>testExecutionMode()\n</code></pre> <p>Test ExecutionMode</p> Source code in <code>src/openapi_client/test/test_execution_mode.py</code> <pre><code>def testExecutionMode(self):\n    \"\"\"Test ExecutionMode\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_http_validation_error/","title":"test_http_validation_error","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/test/test_http_validation_error/#openapi_client.test.test_http_validation_error.TestHTTPValidationError","title":"TestHTTPValidationError","text":"<p>               Bases: <code>TestCase</code></p> <p>HTTPValidationError unit test stubs</p> Source code in <code>src/openapi_client/test/test_http_validation_error.py</code> <pre><code>class TestHTTPValidationError(unittest.TestCase):\n    \"\"\"HTTPValidationError unit test stubs\"\"\"\n\n    def setUp(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def make_instance(self, include_optional) -&gt; HTTPValidationError:\n        \"\"\"Test HTTPValidationError\n        include_optional is a boolean, when False only required\n        params are included, when True both required and\n        optional params are included\"\"\"\n        # uncomment below to create an instance of `HTTPValidationError`\n        \"\"\"\n        model = HTTPValidationError()\n        if include_optional:\n            return HTTPValidationError(\n                detail = [\n                    openapi_client.models.validation_error.ValidationError(\n                        loc = [\n                            null\n                            ],\n                        msg = '',\n                        type = '', )\n                    ]\n            )\n        else:\n            return HTTPValidationError(\n        )\n        \"\"\"\n\n    def testHTTPValidationError(self):\n        \"\"\"Test HTTPValidationError\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_http_validation_error/#openapi_client.test.test_http_validation_error.TestHTTPValidationError.make_instance","title":"make_instance","text":"<pre><code>make_instance(include_optional) -&gt; HTTPValidationError\n</code></pre> <p>Test HTTPValidationError include_optional is a boolean, when False only required params are included, when True both required and optional params are included</p> Source code in <code>src/openapi_client/test/test_http_validation_error.py</code> <pre><code>def make_instance(self, include_optional) -&gt; HTTPValidationError:\n    \"\"\"Test HTTPValidationError\n    include_optional is a boolean, when False only required\n    params are included, when True both required and\n    optional params are included\"\"\"\n    # uncomment below to create an instance of `HTTPValidationError`\n    \"\"\"\n    model = HTTPValidationError()\n    if include_optional:\n        return HTTPValidationError(\n            detail = [\n                openapi_client.models.validation_error.ValidationError(\n                    loc = [\n                        null\n                        ],\n                    msg = '',\n                    type = '', )\n                ]\n        )\n    else:\n        return HTTPValidationError(\n    )\n    \"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_http_validation_error/#openapi_client.test.test_http_validation_error.TestHTTPValidationError.testHTTPValidationError","title":"testHTTPValidationError","text":"<pre><code>testHTTPValidationError()\n</code></pre> <p>Test HTTPValidationError</p> Source code in <code>src/openapi_client/test/test_http_validation_error.py</code> <pre><code>def testHTTPValidationError(self):\n    \"\"\"Test HTTPValidationError\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_job_management_api/","title":"test_job_management_api","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/test/test_job_management_api/#openapi_client.test.test_job_management_api.TestJobManagementApi","title":"TestJobManagementApi","text":"<p>               Bases: <code>TestCase</code></p> <p>JobManagementApi unit test stubs</p> Source code in <code>src/openapi_client/test/test_job_management_api.py</code> <pre><code>class TestJobManagementApi(unittest.TestCase):\n    \"\"\"JobManagementApi unit test stubs\"\"\"\n\n    def setUp(self) -&gt; None:\n        self.api = JobManagementApi()\n\n    def tearDown(self) -&gt; None:\n        pass\n\n    def test_logs_jobs_uid_logs_get(self) -&gt; None:\n        \"\"\"Test case for logs_jobs_uid_logs_get\n\n        Logs\n        \"\"\"\n        pass\n\n    def test_status_jobs_uid_status_get(self) -&gt; None:\n        \"\"\"Test case for status_jobs_uid_status_get\n\n        Status\n        \"\"\"\n        pass\n\n    def test_stop_workload_jobs_uid_stop_post(self) -&gt; None:\n        \"\"\"Test case for stop_workload_jobs_uid_stop_post\n\n        Stop Workload\n        \"\"\"\n        pass\n\n    def test_submit_job_jobs_post(self) -&gt; None:\n        \"\"\"Test case for submit_job_jobs_post\n\n        Submit Job\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/openapi_client/test/test_job_management_api/#openapi_client.test.test_job_management_api.TestJobManagementApi.test_logs_jobs_uid_logs_get","title":"test_logs_jobs_uid_logs_get","text":"<pre><code>test_logs_jobs_uid_logs_get() -&gt; None\n</code></pre> <p>Test case for logs_jobs_uid_logs_get</p> <p>Logs</p> Source code in <code>src/openapi_client/test/test_job_management_api.py</code> <pre><code>def test_logs_jobs_uid_logs_get(self) -&gt; None:\n    \"\"\"Test case for logs_jobs_uid_logs_get\n\n    Logs\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/openapi_client/test/test_job_management_api/#openapi_client.test.test_job_management_api.TestJobManagementApi.test_status_jobs_uid_status_get","title":"test_status_jobs_uid_status_get","text":"<pre><code>test_status_jobs_uid_status_get() -&gt; None\n</code></pre> <p>Test case for status_jobs_uid_status_get</p> <p>Status</p> Source code in <code>src/openapi_client/test/test_job_management_api.py</code> <pre><code>def test_status_jobs_uid_status_get(self) -&gt; None:\n    \"\"\"Test case for status_jobs_uid_status_get\n\n    Status\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/openapi_client/test/test_job_management_api/#openapi_client.test.test_job_management_api.TestJobManagementApi.test_stop_workload_jobs_uid_stop_post","title":"test_stop_workload_jobs_uid_stop_post","text":"<pre><code>test_stop_workload_jobs_uid_stop_post() -&gt; None\n</code></pre> <p>Test case for stop_workload_jobs_uid_stop_post</p> <p>Stop Workload</p> Source code in <code>src/openapi_client/test/test_job_management_api.py</code> <pre><code>def test_stop_workload_jobs_uid_stop_post(self) -&gt; None:\n    \"\"\"Test case for stop_workload_jobs_uid_stop_post\n\n    Stop Workload\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/openapi_client/test/test_job_management_api/#openapi_client.test.test_job_management_api.TestJobManagementApi.test_submit_job_jobs_post","title":"test_submit_job_jobs_post","text":"<pre><code>test_submit_job_jobs_post() -&gt; None\n</code></pre> <p>Test case for submit_job_jobs_post</p> <p>Submit Job</p> Source code in <code>src/openapi_client/test/test_job_management_api.py</code> <pre><code>def test_submit_job_jobs_post(self) -&gt; None:\n    \"\"\"Test case for submit_job_jobs_post\n\n    Submit Job\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/openapi_client/test/test_job_options/","title":"test_job_options","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/test/test_job_options/#openapi_client.test.test_job_options.TestJobOptions","title":"TestJobOptions","text":"<p>               Bases: <code>TestCase</code></p> <p>JobOptions unit test stubs</p> Source code in <code>src/openapi_client/test/test_job_options.py</code> <pre><code>class TestJobOptions(unittest.TestCase):\n    \"\"\"JobOptions unit test stubs\"\"\"\n\n    def setUp(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def make_instance(self, include_optional) -&gt; JobOptions:\n        \"\"\"Test JobOptions\n        include_optional is a boolean, when False only required\n        params are included, when True both required and\n        optional params are included\"\"\"\n        # uncomment below to create an instance of `JobOptions`\n        \"\"\"\n        model = JobOptions()\n        if include_optional:\n            return JobOptions(\n                resources = openapi_client.models.resource_options.ResourceOptions(\n                    memory = '',\n                    cpu = '',\n                    gpu = 56, ),\n                scheduling = openapi_client.models.scheduling_options.SchedulingOptions(\n                    priority_class = '',\n                    queue_name = '', ),\n                labels = {\n                    'key' : ''\n                    }\n            )\n        else:\n            return JobOptions(\n        )\n        \"\"\"\n\n    def testJobOptions(self):\n        \"\"\"Test JobOptions\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_job_options/#openapi_client.test.test_job_options.TestJobOptions.make_instance","title":"make_instance","text":"<pre><code>make_instance(include_optional) -&gt; JobOptions\n</code></pre> <p>Test JobOptions include_optional is a boolean, when False only required params are included, when True both required and optional params are included</p> Source code in <code>src/openapi_client/test/test_job_options.py</code> <pre><code>def make_instance(self, include_optional) -&gt; JobOptions:\n    \"\"\"Test JobOptions\n    include_optional is a boolean, when False only required\n    params are included, when True both required and\n    optional params are included\"\"\"\n    # uncomment below to create an instance of `JobOptions`\n    \"\"\"\n    model = JobOptions()\n    if include_optional:\n        return JobOptions(\n            resources = openapi_client.models.resource_options.ResourceOptions(\n                memory = '',\n                cpu = '',\n                gpu = 56, ),\n            scheduling = openapi_client.models.scheduling_options.SchedulingOptions(\n                priority_class = '',\n                queue_name = '', ),\n            labels = {\n                'key' : ''\n                }\n        )\n    else:\n        return JobOptions(\n    )\n    \"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_job_options/#openapi_client.test.test_job_options.TestJobOptions.testJobOptions","title":"testJobOptions","text":"<pre><code>testJobOptions()\n</code></pre> <p>Test JobOptions</p> Source code in <code>src/openapi_client/test/test_job_options.py</code> <pre><code>def testJobOptions(self):\n    \"\"\"Test JobOptions\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_resource_options/","title":"test_resource_options","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/test/test_resource_options/#openapi_client.test.test_resource_options.TestResourceOptions","title":"TestResourceOptions","text":"<p>               Bases: <code>TestCase</code></p> <p>ResourceOptions unit test stubs</p> Source code in <code>src/openapi_client/test/test_resource_options.py</code> <pre><code>class TestResourceOptions(unittest.TestCase):\n    \"\"\"ResourceOptions unit test stubs\"\"\"\n\n    def setUp(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def make_instance(self, include_optional) -&gt; ResourceOptions:\n        \"\"\"Test ResourceOptions\n        include_optional is a boolean, when False only required\n        params are included, when True both required and\n        optional params are included\"\"\"\n        # uncomment below to create an instance of `ResourceOptions`\n        \"\"\"\n        model = ResourceOptions()\n        if include_optional:\n            return ResourceOptions(\n                memory = '',\n                cpu = '',\n                gpu = 56\n            )\n        else:\n            return ResourceOptions(\n        )\n        \"\"\"\n\n    def testResourceOptions(self):\n        \"\"\"Test ResourceOptions\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_resource_options/#openapi_client.test.test_resource_options.TestResourceOptions.make_instance","title":"make_instance","text":"<pre><code>make_instance(include_optional) -&gt; ResourceOptions\n</code></pre> <p>Test ResourceOptions include_optional is a boolean, when False only required params are included, when True both required and optional params are included</p> Source code in <code>src/openapi_client/test/test_resource_options.py</code> <pre><code>def make_instance(self, include_optional) -&gt; ResourceOptions:\n    \"\"\"Test ResourceOptions\n    include_optional is a boolean, when False only required\n    params are included, when True both required and\n    optional params are included\"\"\"\n    # uncomment below to create an instance of `ResourceOptions`\n    \"\"\"\n    model = ResourceOptions()\n    if include_optional:\n        return ResourceOptions(\n            memory = '',\n            cpu = '',\n            gpu = 56\n        )\n    else:\n        return ResourceOptions(\n    )\n    \"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_resource_options/#openapi_client.test.test_resource_options.TestResourceOptions.testResourceOptions","title":"testResourceOptions","text":"<pre><code>testResourceOptions()\n</code></pre> <p>Test ResourceOptions</p> Source code in <code>src/openapi_client/test/test_resource_options.py</code> <pre><code>def testResourceOptions(self):\n    \"\"\"Test ResourceOptions\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_scheduling_options/","title":"test_scheduling_options","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/test/test_scheduling_options/#openapi_client.test.test_scheduling_options.TestSchedulingOptions","title":"TestSchedulingOptions","text":"<p>               Bases: <code>TestCase</code></p> <p>SchedulingOptions unit test stubs</p> Source code in <code>src/openapi_client/test/test_scheduling_options.py</code> <pre><code>class TestSchedulingOptions(unittest.TestCase):\n    \"\"\"SchedulingOptions unit test stubs\"\"\"\n\n    def setUp(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def make_instance(self, include_optional) -&gt; SchedulingOptions:\n        \"\"\"Test SchedulingOptions\n        include_optional is a boolean, when False only required\n        params are included, when True both required and\n        optional params are included\"\"\"\n        # uncomment below to create an instance of `SchedulingOptions`\n        \"\"\"\n        model = SchedulingOptions()\n        if include_optional:\n            return SchedulingOptions(\n                priority_class = '',\n                queue_name = ''\n            )\n        else:\n            return SchedulingOptions(\n        )\n        \"\"\"\n\n    def testSchedulingOptions(self):\n        \"\"\"Test SchedulingOptions\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_scheduling_options/#openapi_client.test.test_scheduling_options.TestSchedulingOptions.make_instance","title":"make_instance","text":"<pre><code>make_instance(include_optional) -&gt; SchedulingOptions\n</code></pre> <p>Test SchedulingOptions include_optional is a boolean, when False only required params are included, when True both required and optional params are included</p> Source code in <code>src/openapi_client/test/test_scheduling_options.py</code> <pre><code>def make_instance(self, include_optional) -&gt; SchedulingOptions:\n    \"\"\"Test SchedulingOptions\n    include_optional is a boolean, when False only required\n    params are included, when True both required and\n    optional params are included\"\"\"\n    # uncomment below to create an instance of `SchedulingOptions`\n    \"\"\"\n    model = SchedulingOptions()\n    if include_optional:\n        return SchedulingOptions(\n            priority_class = '',\n            queue_name = ''\n        )\n    else:\n        return SchedulingOptions(\n    )\n    \"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_scheduling_options/#openapi_client.test.test_scheduling_options.TestSchedulingOptions.testSchedulingOptions","title":"testSchedulingOptions","text":"<pre><code>testSchedulingOptions()\n</code></pre> <p>Test SchedulingOptions</p> Source code in <code>src/openapi_client/test/test_scheduling_options.py</code> <pre><code>def testSchedulingOptions(self):\n    \"\"\"Test SchedulingOptions\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_validation_error/","title":"test_validation_error","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/test/test_validation_error/#openapi_client.test.test_validation_error.TestValidationError","title":"TestValidationError","text":"<p>               Bases: <code>TestCase</code></p> <p>ValidationError unit test stubs</p> Source code in <code>src/openapi_client/test/test_validation_error.py</code> <pre><code>class TestValidationError(unittest.TestCase):\n    \"\"\"ValidationError unit test stubs\"\"\"\n\n    def setUp(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def make_instance(self, include_optional) -&gt; ValidationError:\n        \"\"\"Test ValidationError\n        include_optional is a boolean, when False only required\n        params are included, when True both required and\n        optional params are included\"\"\"\n        # uncomment below to create an instance of `ValidationError`\n        \"\"\"\n        model = ValidationError()\n        if include_optional:\n            return ValidationError(\n                loc = [\n                    null\n                    ],\n                msg = '',\n                type = ''\n            )\n        else:\n            return ValidationError(\n                loc = [\n                    null\n                    ],\n                msg = '',\n                type = '',\n        )\n        \"\"\"\n\n    def testValidationError(self):\n        \"\"\"Test ValidationError\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_validation_error/#openapi_client.test.test_validation_error.TestValidationError.make_instance","title":"make_instance","text":"<pre><code>make_instance(include_optional) -&gt; ValidationError\n</code></pre> <p>Test ValidationError include_optional is a boolean, when False only required params are included, when True both required and optional params are included</p> Source code in <code>src/openapi_client/test/test_validation_error.py</code> <pre><code>def make_instance(self, include_optional) -&gt; ValidationError:\n    \"\"\"Test ValidationError\n    include_optional is a boolean, when False only required\n    params are included, when True both required and\n    optional params are included\"\"\"\n    # uncomment below to create an instance of `ValidationError`\n    \"\"\"\n    model = ValidationError()\n    if include_optional:\n        return ValidationError(\n            loc = [\n                null\n                ],\n            msg = '',\n            type = ''\n        )\n    else:\n        return ValidationError(\n            loc = [\n                null\n                ],\n            msg = '',\n            type = '',\n    )\n    \"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_validation_error/#openapi_client.test.test_validation_error.TestValidationError.testValidationError","title":"testValidationError","text":"<pre><code>testValidationError()\n</code></pre> <p>Test ValidationError</p> Source code in <code>src/openapi_client/test/test_validation_error.py</code> <pre><code>def testValidationError(self):\n    \"\"\"Test ValidationError\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_validation_error_loc_inner/","title":"test_validation_error_loc_inner","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/test/test_validation_error_loc_inner/#openapi_client.test.test_validation_error_loc_inner.TestValidationErrorLocInner","title":"TestValidationErrorLocInner","text":"<p>               Bases: <code>TestCase</code></p> <p>ValidationErrorLocInner unit test stubs</p> Source code in <code>src/openapi_client/test/test_validation_error_loc_inner.py</code> <pre><code>class TestValidationErrorLocInner(unittest.TestCase):\n    \"\"\"ValidationErrorLocInner unit test stubs\"\"\"\n\n    def setUp(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def make_instance(self, include_optional) -&gt; ValidationErrorLocInner:\n        \"\"\"Test ValidationErrorLocInner\n        include_optional is a boolean, when False only required\n        params are included, when True both required and\n        optional params are included\"\"\"\n        # uncomment below to create an instance of `ValidationErrorLocInner`\n        \"\"\"\n        model = ValidationErrorLocInner()\n        if include_optional:\n            return ValidationErrorLocInner(\n            )\n        else:\n            return ValidationErrorLocInner(\n        )\n        \"\"\"\n\n    def testValidationErrorLocInner(self):\n        \"\"\"Test ValidationErrorLocInner\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_validation_error_loc_inner/#openapi_client.test.test_validation_error_loc_inner.TestValidationErrorLocInner.make_instance","title":"make_instance","text":"<pre><code>make_instance(include_optional) -&gt; ValidationErrorLocInner\n</code></pre> <p>Test ValidationErrorLocInner include_optional is a boolean, when False only required params are included, when True both required and optional params are included</p> Source code in <code>src/openapi_client/test/test_validation_error_loc_inner.py</code> <pre><code>def make_instance(self, include_optional) -&gt; ValidationErrorLocInner:\n    \"\"\"Test ValidationErrorLocInner\n    include_optional is a boolean, when False only required\n    params are included, when True both required and\n    optional params are included\"\"\"\n    # uncomment below to create an instance of `ValidationErrorLocInner`\n    \"\"\"\n    model = ValidationErrorLocInner()\n    if include_optional:\n        return ValidationErrorLocInner(\n        )\n    else:\n        return ValidationErrorLocInner(\n    )\n    \"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_validation_error_loc_inner/#openapi_client.test.test_validation_error_loc_inner.TestValidationErrorLocInner.testValidationErrorLocInner","title":"testValidationErrorLocInner","text":"<pre><code>testValidationErrorLocInner()\n</code></pre> <p>Test ValidationErrorLocInner</p> Source code in <code>src/openapi_client/test/test_validation_error_loc_inner.py</code> <pre><code>def testValidationErrorLocInner(self):\n    \"\"\"Test ValidationErrorLocInner\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_workload_identifier/","title":"test_workload_identifier","text":"<p>infrastructure-product API</p> <p>Backend service for the appliedAI infrastructure product</p> <p>The version of the OpenAPI document: 0.1.0 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"reference/openapi_client/test/test_workload_identifier/#openapi_client.test.test_workload_identifier.TestWorkloadIdentifier","title":"TestWorkloadIdentifier","text":"<p>               Bases: <code>TestCase</code></p> <p>WorkloadIdentifier unit test stubs</p> Source code in <code>src/openapi_client/test/test_workload_identifier.py</code> <pre><code>class TestWorkloadIdentifier(unittest.TestCase):\n    \"\"\"WorkloadIdentifier unit test stubs\"\"\"\n\n    def setUp(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def make_instance(self, include_optional) -&gt; WorkloadIdentifier:\n        \"\"\"Test WorkloadIdentifier\n        include_optional is a boolean, when False only required\n        params are included, when True both required and\n        optional params are included\"\"\"\n        # uncomment below to create an instance of `WorkloadIdentifier`\n        \"\"\"\n        model = WorkloadIdentifier()\n        if include_optional:\n            return WorkloadIdentifier(\n                group = '',\n                version = '',\n                kind = '',\n                namespace = '',\n                uid = ''\n            )\n        else:\n            return WorkloadIdentifier(\n                group = '',\n                version = '',\n                kind = '',\n                namespace = '',\n                uid = '',\n        )\n        \"\"\"\n\n    def testWorkloadIdentifier(self):\n        \"\"\"Test WorkloadIdentifier\"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_workload_identifier/#openapi_client.test.test_workload_identifier.TestWorkloadIdentifier.make_instance","title":"make_instance","text":"<pre><code>make_instance(include_optional) -&gt; WorkloadIdentifier\n</code></pre> <p>Test WorkloadIdentifier include_optional is a boolean, when False only required params are included, when True both required and optional params are included</p> Source code in <code>src/openapi_client/test/test_workload_identifier.py</code> <pre><code>def make_instance(self, include_optional) -&gt; WorkloadIdentifier:\n    \"\"\"Test WorkloadIdentifier\n    include_optional is a boolean, when False only required\n    params are included, when True both required and\n    optional params are included\"\"\"\n    # uncomment below to create an instance of `WorkloadIdentifier`\n    \"\"\"\n    model = WorkloadIdentifier()\n    if include_optional:\n        return WorkloadIdentifier(\n            group = '',\n            version = '',\n            kind = '',\n            namespace = '',\n            uid = ''\n        )\n    else:\n        return WorkloadIdentifier(\n            group = '',\n            version = '',\n            kind = '',\n            namespace = '',\n            uid = '',\n    )\n    \"\"\"\n</code></pre>"},{"location":"reference/openapi_client/test/test_workload_identifier/#openapi_client.test.test_workload_identifier.TestWorkloadIdentifier.testWorkloadIdentifier","title":"testWorkloadIdentifier","text":"<pre><code>testWorkloadIdentifier()\n</code></pre> <p>Test WorkloadIdentifier</p> Source code in <code>src/openapi_client/test/test_workload_identifier.py</code> <pre><code>def testWorkloadIdentifier(self):\n    \"\"\"Test WorkloadIdentifier\"\"\"\n</code></pre>"}]}